{"config":{"indexing":"full","lang":["en","fr"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Home Revision 2 september 2024 Software WRSimulator Version 1.5 on WinRelay Studio 2.5.0 (2.5c) Author Fr\u00e9d\u00e9ric POPEK Editor INGEREA Simulator objectives The aim of the simulator is to enable users to simulate electrical, electrotechnical and pneumatic circuits for educational purposes and for pre-project presentation. In particular, the simulator can be used to simulate automated production system-type installations using a virtual or physical PLC connected via MODBUS/TCP-IP, coupled with an animated operating section. The simulator incorporates a mixed analog/digital simulation model, enabling simultaneous simulation of: - standard electrical/electrotechnical circuits, - pneumatic circuits, - complex objects (speed controllers, safety relays, etc.) - programmable logic controllers, - simple operating parts. First steps Open an example Open an example from WinRelais File>Open wr-schematic/Simulator_Demos/ . A quick access to the Simulator_Demos folder is built into the installation. This allows you to launch WinRelais directly with the selected example. Launch simulator Click on the icon: Simulator controls Simulator checks give three levels of warning: Warning list","title":"Home"},{"location":"#home","text":"Revision 2 september 2024 Software WRSimulator Version 1.5 on WinRelay Studio 2.5.0 (2.5c) Author Fr\u00e9d\u00e9ric POPEK Editor INGEREA","title":"Home"},{"location":"#simulator-objectives","text":"The aim of the simulator is to enable users to simulate electrical, electrotechnical and pneumatic circuits for educational purposes and for pre-project presentation. In particular, the simulator can be used to simulate automated production system-type installations using a virtual or physical PLC connected via MODBUS/TCP-IP, coupled with an animated operating section. The simulator incorporates a mixed analog/digital simulation model, enabling simultaneous simulation of: - standard electrical/electrotechnical circuits, - pneumatic circuits, - complex objects (speed controllers, safety relays, etc.) - programmable logic controllers, - simple operating parts.","title":"Simulator objectives"},{"location":"#first-steps","text":"","title":"First steps"},{"location":"#open-an-example","text":"Open an example from WinRelais File>Open wr-schematic/Simulator_Demos/ . A quick access to the Simulator_Demos folder is built into the installation. This allows you to launch WinRelais directly with the selected example.","title":"Open an example"},{"location":"#launch-simulator","text":"Click on the icon:","title":"Launch simulator"},{"location":"#simulator-controls","text":"Simulator checks give three levels of warning: Warning list","title":"Simulator controls"},{"location":"errors/","text":"Warnings list When the simulator is launched, checks are made on the schematic to be simulated. Blocking warnings : the simulator stops checking at the first error encountered, and prevents simulation until the error has been resolved. Non-blocking warnings : the simulator replaces the value of parameters not found or unreadable by default values and authorizes simulation anyway. Blocking warnings BLOCKING {nb_doublons} objects named {name} are present in the schematic, only one is allowed the {master} component is missing to control the {slave} the {slave} object is incompatible with the {master} object The {name} object that controls steering is not a motor object {name} that controls steering does not exist Erroneous API address: Expected format: %{I,Q}m.c with m[0.5] and c[0.31], example: %I1.12 Erroneous API address: Expected format: %{IW, QW}m.c with m[0.5] and c[0.3], example: %IW1.1 The parent of the API object does not exist I/O marker unreadable: must start with % Parent {name} does not exist pin {pin} of object {name} is not connected 'dropped_object' {name} does not exist 'dropped_object' {name} is not an object of the '_physics'family object {label_pression} is not a label_pression object {label_pression} does not exist the key 'controle1' of {name'} is undefined key 'controle2' of {name'} is undefined control object {ctrl} missing for {slave} the two objects named {name} must be of type SET and RESET the number of {name} objects must be strictly equal to 2 (SET and RESET) two objects named {name} have incompatible families: {slave} and {master} HMI object {name} is incompatible with object {name} sensor collision identifier {name} doesn't find a match false connection found: invalid arrival/departure folio sending {sending} in folio {folio} not connected object {name} {folio} is not simulatable the schema to be simulated is too large serious problem for the component: software bug. Please contact support Non-blocking warnings {OUT_INTERVAL} 'alpha' {OFF_INTERVAL} (0 <= alpha <= 100), value set to 50%\" 'hang' {OFF_INTERVAL} [true,false], value set to false 'etat_init' {HORS_INTERVALLE} [true,false], value set to false 'delai' {HORS_INTERVALLE} (0.1 <= delai <= 30), value set to 1s 'mass' {OFF_INTERVAL} (0.1 <= mass <= 100 kg) 'friction' {OFF_INTERVAL} (0 <= friction <= 100) 'port' {OFF_INTERVAL} (500 <= port <= 1000), value set to 502 'adresse_table_echange' (0 <= adress <= 1990), value set to 400 'ID_unite' {OFF_INTERVAL} (0 <= ID_unite <= 247), value set to 111 'gravity' {OFF_INTERVAL} (0 <= gravity <= 10), set value 0 'damping' {HORS_INTERVALLE} (0 <= damping <= 10), value set to 0 'damping' {OFF_INTERVAL} (0 <= damping <= 10), {VALUE_SET_TO} 0 'value' {OFF_INTERVAL} (1pF <= value <= 10000uF), value set to 100uF 'value' {OFF_INTERVAL} (1e-3 <= value <= 10e6), value set to 100 ohms 'value' {OFF_INTERVAL} (1e-3 <= value <= 10e6), value set to 100 ohms 'alpha' {OFF_INTERVAL} (0 <= alpha <= 100), value set to 50% 'pn' {HORS_INTERVALLE} (10 W <= Pn <= 22 kW), value set to {values['pn']/1000} kW 'vn' {OFF_INTERVAL} (12 <= vn <= 400 V), value set to {values['vn']} V 'vfrein' {OFF_INTERVAL} (12 <= v <= 400), value set to {values['vn']} V 'nm' {OFF_INTERVAL} (700 <= nm <= 3000), value set to {values['nm']} rpm 'nm1' {OFF_INTERVAL} (700 <= nm1 <= 3000), value set to {values['nm1']} rpm 'nm2' {OFF_INTERVAL} (700 <= nm2 <= 3000), value set to {values['nm2']} rpm 'cos' {OFF_INTERVAL} (0.5 <= cos(phi) <= 1), value set to {values['cos']} 'yield' {OFF_INTERVAL} (0.35 <= yield <= 1), value set to {values['yield']} venroulement' {HORS_INTERVALLE} (24V <= venroulement <= 400V), value set to 230 V 'venroulement1' {HORS_INTERVALLE} (24V <= vcoil1 <= 400V), value set to 230 V 'venroulement2' {HORS_INTERVALLE} (24V <= venroulement2 <= 400V), value set to 230 V vinduit' {OFF_INTERVAL} (12V <= vinduit <= 320V), value set to 100 V 'coupling' {OFF_INTERVAL} (star or delta), selected coupling: star 'coupling1' {OFF_INTERVAL} (star or delta), selected coupling: star 'coupling2' {HORS_INTERVALLE} (star or delta), selected coupling: star Idn' {OFF_INTERVAL} (10 mA <= Idn <= 10000 mA), value set to 100 mA 'retard_diff' {OFF_INTERVAL} (0 ms<= retard_diff <= 10000 ms), value set to 0 ms 'retard_rth' {HORS_INTERVALLE} (1s<= retard_rth <= 30s ), value set to 10 s 'retard' {HORS_INTERVALLE} (0 ms<= retard <= 10000 ms), value set to 0ms 'retard_rth' {HORS_INTERVALLE} (1s<= retard_rth <= 30s ), value set to 10 s 'retard' {OFF_INTERVAL} (0 ms<= retard <= 10000 ms), value set to 0 ms 'Ith' {OFF_INTERVAL} (0.1 A<= Ith <= 100 A), value set to 10 A 'In' {OFF_INTERVAL} (0.5 A<= In <= 100 A), value set to 10 A 'curve' {OFF_INTERVAL} (B, C or D), value set to C 'typeF' {OFF_INTERVAL} (gG or aM), type selected: aM 'Pn' {OFF_INTERVAL} (0.5 VA <= Pn <= 200 VA), value set to {values['pn']} W 'vn' {OFF_INTERVAL} (12 <= vn <= 400), value set to {values['vn']} V 'Pn' {OFF_INTERVAL} (0.5 W <= Pn <= 2 kW), value set to {values['pn']} W 'color' {OFF_INTERVAL} (red, green, blue, orange, white), value set to 'red' 'tone' {OFF_INTERVAL} (0.5s <= tone <= 30s), value set to 1s 'toff' {OFF_INTERVAL} (0.5s <= toff <= 30s), value set to 1s 'output_range' {OFF_INTERVAL} min value = (0, 4) and max value = 20, value set to (4,20) mA 'output_range' {OFF_INTERVAL} min value = -30 and max value = 30, value set to (0.10) V 'output_scale' {OFF_INTERVAL} min value = -32768 and max value = 32767, value set to (0.1000) 'input_scale' {OFF_INTERVAL} min value = -32768 and max value = 32767, value set to (0,1000) 'voltage_range' {OFF_INTERVAL} min value = -1000 and max value = 1000, value set to (0.10) V 'current_range' {OFF_INTERVAL} (min,max) = (-1, 1) A, value set to (4,20) mA 'pressure' {OFF_INTERVAL} (0 <= pressure <= 10.0 bar), value set to 6 bar 've' {OFF_INTERVAL} (5 <= ve <= 400), value set to {values['vin']} V 'vs' {OFF_INTERVAL} (5 <= vs <= 400), value set to {values['vout']} V 'vs1' {OFF_INTERVAL} (5 <= vs1 <= 400), value set to {values['vout1']} V 'vs2' {OFF_INTERVAL} (5 <= vs2 <= 400), value set to {values['vout2']} V 'vbat' {OFF_INTERVAL} (0 <= vbat <= 400), value set to {values['vbat']} V {power} {OFF_INTERVAL} (90 W <= {power} <= 22 kW), value set to {values[{power}]/1000} kW UNREADABLE 'masse' {UNREADABLE} value set to 1 kg 'friction' {UNREADABLE} value set to 1 'ip_address' {UNREADABLE} value set to 127.0.0.1 'port' {UNREADABLE} value set to 502 'adresse_table_echange' {UNREADABLE} value set to 400 'ID_unite' {UNREADABLE} value set to 111 'gravity' {UNREADABLE} value set to 0 'damping' {UNREADABLE} value set to 0 'damping' {UNREADABLE} {VALUE_SET_TO} 0 'value' {UNREADABLE} value set to 100 uF 'value' {UNREADABLE} value set to 100 ohms 'value' {UNREADABLE} value set to 100 ohms 'alpha' {UNREADABLE} value set to 50% 'Pn' {UNREADABLE} value set to {values['pn']/1000} kW 'vn' {UNREADABLE} value set to {values['vn']} V 'v' {UNREADABLE} value set to {values['vn']} V 'nm' {UNREADABLE} value set to {values['nm']} rpm 'nm1' {UNREADABLE} value set to {values['nm1']} rpm 'nm2' {UNREADABLE} value set to {values['nm2']} rpm 'cos' {UNREADABLE} value set to {values['cos']} 'rendement' {UNREADABLE} value set to {values['rendement']} 'venroulement' {UNREADABLE} value set to {values['venroulement']/0.98:2.0f} V 'venroulement1' {UNREADABLE} value set to {values['venroulement1']/0.98:2.0f} V 'venroulement2' {UNREADABLE} value set to {values['venroulement2']/0.98:2.0f} V 'vinduit' {UNREADABLE} value set to {values['va']/0.98:2.0f} V 'Idn' {UNREADABLE} value set to {values['idn']} mA 'retard_diff' {UNREADABLE} {VALUE_SET_TO} {values['retard_diff']} ms 'retard_rth' {UNREADABLE} value set to {values['retard_rth']} s 'retard' {UNREADABLE} value set to {values['retard']} ms 'Ith' {UNREADABLE} {VALUE_SET_TO} {values['ith']} A 'In' {UNREADABLE} value set to {values['in']} A 'pn' {UNREADABLE} value set to {values['pn']} W 'vn' {UNREADABLE} value set to {values['vn']} V 'color' {UNREADABLE} value set to 'red' 'vn' {UNREADABLE} value set to 24 V 'ton' {UNREADABLE} value set to 1s 'toff' {UNREADABLE} value set to 1s output_type' {UNREADABLE} (output_type = V or I), 'output_type' set to 'V' 'output_type' {UNREADABLE} (output_type = V or I), 'output_type' set to 'V' 'output_range' {UNREADABLE} value set to (4.20) mA 'output_range' {UNREADABLE} value set to (0.10) V 'output_scale' {UNREADABLE} value set to (0,1000) input_type' {UNREADABLE} (input_type = V or I), 'input_type' set to 'V' 'input_type' {UNREADABLE} (input_type = V or I), 'input_type' set to 'V' 'input_range' {UNREADABLE} value set to (4.20) mA 'input_range' {UNREADABLE} value set to (0.10) V 'input_scale' {UNREADABLE} value set to (0,1000) 'voltage_range' {UNREADABLE} value set to (0,10) V 'current_range' {UNREADABLE} value set to (4.20) mA 'pressure' {UNREADABLE} value set to {values['pressure']} bar 've' {UNREADABLE} value set to {values['vin']} V 'vs' {UNREADABLE} value set to {values['vout']} V 'vs1' {UNREADABLE} value set to {values['vout1']} V 'vs2' {UNREADABLE} value set to {values['vout2']} V 'vbat' {UNREADABLE} value set to {values['vbat']} V 'format' {UNREADABLE} (format = ac or dc), 'format' set to 'dc' {power} {UNREADABLE} value set to {values[{power}]/1000} kW parameter {k} {UNREADABLE} factory value {values[k]} {limits[k][0]} selected","title":"Warning list"},{"location":"errors/#warnings-list","text":"When the simulator is launched, checks are made on the schematic to be simulated. Blocking warnings : the simulator stops checking at the first error encountered, and prevents simulation until the error has been resolved. Non-blocking warnings : the simulator replaces the value of parameters not found or unreadable by default values and authorizes simulation anyway.","title":"Warnings list"},{"location":"errors/#blocking-warnings","text":"BLOCKING {nb_doublons} objects named {name} are present in the schematic, only one is allowed the {master} component is missing to control the {slave} the {slave} object is incompatible with the {master} object The {name} object that controls steering is not a motor object {name} that controls steering does not exist Erroneous API address: Expected format: %{I,Q}m.c with m[0.5] and c[0.31], example: %I1.12 Erroneous API address: Expected format: %{IW, QW}m.c with m[0.5] and c[0.3], example: %IW1.1 The parent of the API object does not exist I/O marker unreadable: must start with % Parent {name} does not exist pin {pin} of object {name} is not connected 'dropped_object' {name} does not exist 'dropped_object' {name} is not an object of the '_physics'family object {label_pression} is not a label_pression object {label_pression} does not exist the key 'controle1' of {name'} is undefined key 'controle2' of {name'} is undefined control object {ctrl} missing for {slave} the two objects named {name} must be of type SET and RESET the number of {name} objects must be strictly equal to 2 (SET and RESET) two objects named {name} have incompatible families: {slave} and {master} HMI object {name} is incompatible with object {name} sensor collision identifier {name} doesn't find a match false connection found: invalid arrival/departure folio sending {sending} in folio {folio} not connected object {name} {folio} is not simulatable the schema to be simulated is too large serious problem for the component: software bug. Please contact support","title":"Blocking warnings"},{"location":"errors/#non-blocking-warnings","text":"{OUT_INTERVAL} 'alpha' {OFF_INTERVAL} (0 <= alpha <= 100), value set to 50%\" 'hang' {OFF_INTERVAL} [true,false], value set to false 'etat_init' {HORS_INTERVALLE} [true,false], value set to false 'delai' {HORS_INTERVALLE} (0.1 <= delai <= 30), value set to 1s 'mass' {OFF_INTERVAL} (0.1 <= mass <= 100 kg) 'friction' {OFF_INTERVAL} (0 <= friction <= 100) 'port' {OFF_INTERVAL} (500 <= port <= 1000), value set to 502 'adresse_table_echange' (0 <= adress <= 1990), value set to 400 'ID_unite' {OFF_INTERVAL} (0 <= ID_unite <= 247), value set to 111 'gravity' {OFF_INTERVAL} (0 <= gravity <= 10), set value 0 'damping' {HORS_INTERVALLE} (0 <= damping <= 10), value set to 0 'damping' {OFF_INTERVAL} (0 <= damping <= 10), {VALUE_SET_TO} 0 'value' {OFF_INTERVAL} (1pF <= value <= 10000uF), value set to 100uF 'value' {OFF_INTERVAL} (1e-3 <= value <= 10e6), value set to 100 ohms 'value' {OFF_INTERVAL} (1e-3 <= value <= 10e6), value set to 100 ohms 'alpha' {OFF_INTERVAL} (0 <= alpha <= 100), value set to 50% 'pn' {HORS_INTERVALLE} (10 W <= Pn <= 22 kW), value set to {values['pn']/1000} kW 'vn' {OFF_INTERVAL} (12 <= vn <= 400 V), value set to {values['vn']} V 'vfrein' {OFF_INTERVAL} (12 <= v <= 400), value set to {values['vn']} V 'nm' {OFF_INTERVAL} (700 <= nm <= 3000), value set to {values['nm']} rpm 'nm1' {OFF_INTERVAL} (700 <= nm1 <= 3000), value set to {values['nm1']} rpm 'nm2' {OFF_INTERVAL} (700 <= nm2 <= 3000), value set to {values['nm2']} rpm 'cos' {OFF_INTERVAL} (0.5 <= cos(phi) <= 1), value set to {values['cos']} 'yield' {OFF_INTERVAL} (0.35 <= yield <= 1), value set to {values['yield']} venroulement' {HORS_INTERVALLE} (24V <= venroulement <= 400V), value set to 230 V 'venroulement1' {HORS_INTERVALLE} (24V <= vcoil1 <= 400V), value set to 230 V 'venroulement2' {HORS_INTERVALLE} (24V <= venroulement2 <= 400V), value set to 230 V vinduit' {OFF_INTERVAL} (12V <= vinduit <= 320V), value set to 100 V 'coupling' {OFF_INTERVAL} (star or delta), selected coupling: star 'coupling1' {OFF_INTERVAL} (star or delta), selected coupling: star 'coupling2' {HORS_INTERVALLE} (star or delta), selected coupling: star Idn' {OFF_INTERVAL} (10 mA <= Idn <= 10000 mA), value set to 100 mA 'retard_diff' {OFF_INTERVAL} (0 ms<= retard_diff <= 10000 ms), value set to 0 ms 'retard_rth' {HORS_INTERVALLE} (1s<= retard_rth <= 30s ), value set to 10 s 'retard' {HORS_INTERVALLE} (0 ms<= retard <= 10000 ms), value set to 0ms 'retard_rth' {HORS_INTERVALLE} (1s<= retard_rth <= 30s ), value set to 10 s 'retard' {OFF_INTERVAL} (0 ms<= retard <= 10000 ms), value set to 0 ms 'Ith' {OFF_INTERVAL} (0.1 A<= Ith <= 100 A), value set to 10 A 'In' {OFF_INTERVAL} (0.5 A<= In <= 100 A), value set to 10 A 'curve' {OFF_INTERVAL} (B, C or D), value set to C 'typeF' {OFF_INTERVAL} (gG or aM), type selected: aM 'Pn' {OFF_INTERVAL} (0.5 VA <= Pn <= 200 VA), value set to {values['pn']} W 'vn' {OFF_INTERVAL} (12 <= vn <= 400), value set to {values['vn']} V 'Pn' {OFF_INTERVAL} (0.5 W <= Pn <= 2 kW), value set to {values['pn']} W 'color' {OFF_INTERVAL} (red, green, blue, orange, white), value set to 'red' 'tone' {OFF_INTERVAL} (0.5s <= tone <= 30s), value set to 1s 'toff' {OFF_INTERVAL} (0.5s <= toff <= 30s), value set to 1s 'output_range' {OFF_INTERVAL} min value = (0, 4) and max value = 20, value set to (4,20) mA 'output_range' {OFF_INTERVAL} min value = -30 and max value = 30, value set to (0.10) V 'output_scale' {OFF_INTERVAL} min value = -32768 and max value = 32767, value set to (0.1000) 'input_scale' {OFF_INTERVAL} min value = -32768 and max value = 32767, value set to (0,1000) 'voltage_range' {OFF_INTERVAL} min value = -1000 and max value = 1000, value set to (0.10) V 'current_range' {OFF_INTERVAL} (min,max) = (-1, 1) A, value set to (4,20) mA 'pressure' {OFF_INTERVAL} (0 <= pressure <= 10.0 bar), value set to 6 bar 've' {OFF_INTERVAL} (5 <= ve <= 400), value set to {values['vin']} V 'vs' {OFF_INTERVAL} (5 <= vs <= 400), value set to {values['vout']} V 'vs1' {OFF_INTERVAL} (5 <= vs1 <= 400), value set to {values['vout1']} V 'vs2' {OFF_INTERVAL} (5 <= vs2 <= 400), value set to {values['vout2']} V 'vbat' {OFF_INTERVAL} (0 <= vbat <= 400), value set to {values['vbat']} V {power} {OFF_INTERVAL} (90 W <= {power} <= 22 kW), value set to {values[{power}]/1000} kW UNREADABLE 'masse' {UNREADABLE} value set to 1 kg 'friction' {UNREADABLE} value set to 1 'ip_address' {UNREADABLE} value set to 127.0.0.1 'port' {UNREADABLE} value set to 502 'adresse_table_echange' {UNREADABLE} value set to 400 'ID_unite' {UNREADABLE} value set to 111 'gravity' {UNREADABLE} value set to 0 'damping' {UNREADABLE} value set to 0 'damping' {UNREADABLE} {VALUE_SET_TO} 0 'value' {UNREADABLE} value set to 100 uF 'value' {UNREADABLE} value set to 100 ohms 'value' {UNREADABLE} value set to 100 ohms 'alpha' {UNREADABLE} value set to 50% 'Pn' {UNREADABLE} value set to {values['pn']/1000} kW 'vn' {UNREADABLE} value set to {values['vn']} V 'v' {UNREADABLE} value set to {values['vn']} V 'nm' {UNREADABLE} value set to {values['nm']} rpm 'nm1' {UNREADABLE} value set to {values['nm1']} rpm 'nm2' {UNREADABLE} value set to {values['nm2']} rpm 'cos' {UNREADABLE} value set to {values['cos']} 'rendement' {UNREADABLE} value set to {values['rendement']} 'venroulement' {UNREADABLE} value set to {values['venroulement']/0.98:2.0f} V 'venroulement1' {UNREADABLE} value set to {values['venroulement1']/0.98:2.0f} V 'venroulement2' {UNREADABLE} value set to {values['venroulement2']/0.98:2.0f} V 'vinduit' {UNREADABLE} value set to {values['va']/0.98:2.0f} V 'Idn' {UNREADABLE} value set to {values['idn']} mA 'retard_diff' {UNREADABLE} {VALUE_SET_TO} {values['retard_diff']} ms 'retard_rth' {UNREADABLE} value set to {values['retard_rth']} s 'retard' {UNREADABLE} value set to {values['retard']} ms 'Ith' {UNREADABLE} {VALUE_SET_TO} {values['ith']} A 'In' {UNREADABLE} value set to {values['in']} A 'pn' {UNREADABLE} value set to {values['pn']} W 'vn' {UNREADABLE} value set to {values['vn']} V 'color' {UNREADABLE} value set to 'red' 'vn' {UNREADABLE} value set to 24 V 'ton' {UNREADABLE} value set to 1s 'toff' {UNREADABLE} value set to 1s output_type' {UNREADABLE} (output_type = V or I), 'output_type' set to 'V' 'output_type' {UNREADABLE} (output_type = V or I), 'output_type' set to 'V' 'output_range' {UNREADABLE} value set to (4.20) mA 'output_range' {UNREADABLE} value set to (0.10) V 'output_scale' {UNREADABLE} value set to (0,1000) input_type' {UNREADABLE} (input_type = V or I), 'input_type' set to 'V' 'input_type' {UNREADABLE} (input_type = V or I), 'input_type' set to 'V' 'input_range' {UNREADABLE} value set to (4.20) mA 'input_range' {UNREADABLE} value set to (0.10) V 'input_scale' {UNREADABLE} value set to (0,1000) 'voltage_range' {UNREADABLE} value set to (0,10) V 'current_range' {UNREADABLE} value set to (4.20) mA 'pressure' {UNREADABLE} value set to {values['pressure']} bar 've' {UNREADABLE} value set to {values['vin']} V 'vs' {UNREADABLE} value set to {values['vout']} V 'vs1' {UNREADABLE} value set to {values['vout1']} V 'vs2' {UNREADABLE} value set to {values['vout2']} V 'vbat' {UNREADABLE} value set to {values['vbat']} V 'format' {UNREADABLE} (format = ac or dc), 'format' set to 'dc' {power} {UNREADABLE} value set to {values[{power}]/1000} kW parameter {k} {UNREADABLE} factory value {values[k]} {limits[k][0]} selected","title":"Non-blocking warnings"},{"location":"grapher/","text":"Grapher This module allows you to draw a chronogram (up to 16 variables) during simulation: You must first prepare the list of variables to be displayed in a text zone edited in WinRelais, for example : ( us19 - demo_Speed_Drive_ATV31_3ph_3C ) The first line of the text box must begin with the keyword Grapher , this text box can be placed anywhere in the layout, a specific icon appears during simulation if the Grapher text zone is detected, variable order determines chronogram display order, the syntax used to define a variable is : name_object.control[.caliber] control description example state status active/not active fdc_haut.state : status of high limit switch speed motor object speed M1.speed : M1 motor speed direction sense of rotation motor object M1.rotation : direction of rotation of motor M1 value.caliber measured value and caliber A1.value.10 : current measured by ammeter A1 calibrated 10 A","title":"Grapher"},{"location":"grapher/#grapher","text":"This module allows you to draw a chronogram (up to 16 variables) during simulation: You must first prepare the list of variables to be displayed in a text zone edited in WinRelais, for example : ( us19 - demo_Speed_Drive_ATV31_3ph_3C ) The first line of the text box must begin with the keyword Grapher , this text box can be placed anywhere in the layout, a specific icon appears during simulation if the Grapher text zone is detected, variable order determines chronogram display order, the syntax used to define a variable is : name_object.control[.caliber] control description example state status active/not active fdc_haut.state : status of high limit switch speed motor object speed M1.speed : M1 motor speed direction sense of rotation motor object M1.rotation : direction of rotation of motor M1 value.caliber measured value and caliber A1.value.10 : current measured by ammeter A1 calibrated 10 A","title":"Grapher"},{"location":"hmi/","text":"Human Machine Interface hmi components can be modified in WinSymbole. Variants of ihm components can be created by adding the suffix #my variant after the component root. Example: Light voyant library /_hmi texture_name = foreground texture in png format texture_name2 = optional background texture in png format Push button / Slide button pushbutton, slide_button library /_hmi hooking = False/True texture_name = foreground texture in png format texture_name2 = optional background texture in png format state = fixes active/non-active button state, only if snap = True Switch switch_2pos, switch_3pos library /_hmi hooking = False/True texture_name = foreground texture in png format texture_name2 = optional background texture in png format state = 0,1,2: switch position, only if snap = True Potentiometer rotating_knob, horizontal_linear_knob, vertical_linear_knob library /_hmi alpha = [0 to 100%] texture_name = foreground texture in png format texture_name2 = optional background texture in png format * fixes the display position of the % set by the button Composition Adjustable simulable components must be associated with an ihm component. Library _divers_pneumatic : Library _sensors Library _resistors - The association of an ihm component is not mandatory for resistor components.","title":"Human Machine Interface"},{"location":"hmi/#human-machine-interface","text":"hmi components can be modified in WinSymbole. Variants of ihm components can be created by adding the suffix #my variant after the component root. Example:","title":"Human Machine Interface"},{"location":"hmi/#light","text":"voyant library /_hmi texture_name = foreground texture in png format texture_name2 = optional background texture in png format","title":"Light"},{"location":"hmi/#push-button-slide-button","text":"pushbutton, slide_button library /_hmi hooking = False/True texture_name = foreground texture in png format texture_name2 = optional background texture in png format state = fixes active/non-active button state, only if snap = True","title":"Push button / Slide button"},{"location":"hmi/#switch","text":"switch_2pos, switch_3pos library /_hmi hooking = False/True texture_name = foreground texture in png format texture_name2 = optional background texture in png format state = 0,1,2: switch position, only if snap = True","title":"Switch"},{"location":"hmi/#potentiometer","text":"rotating_knob, horizontal_linear_knob, vertical_linear_knob library /_hmi alpha = [0 to 100%] texture_name = foreground texture in png format texture_name2 = optional background texture in png format * fixes the display position of the % set by the button","title":"Potentiometer"},{"location":"hmi/#composition","text":"Adjustable simulable components must be associated with an ihm component. Library _divers_pneumatic : Library _sensors Library _resistors - The association of an ihm component is not mandatory for resistor components.","title":"Composition"},{"location":"library/","text":"Simulable library Access WinRelais exposes the library of simulatable components (folder D4) using three methods: The explorer provides easy access to the blocks_simulables folder, which can be used to retrieve complete simulation subsets: Method 1: place a symbol Method 2: search and place a symbol Method 3: explore and place a symbol using drag & drop Create a symbol from an existing symbol You can create a new symbol from an existing one, adapting its design and terminal layout as required. The new symbol inherits all the simulation logic of the parent symbol. The visual of the symbol can be defined with WinSymbol or with an image (also called texture) in png format. Constraints : Pin names must not be modified. The number of pins may not be changed. Example 1 : We want to create a square-shaped ammeter symbol. Place the 'amperemeter' symbol on the folio. Go to Modify a Symbol and select Run WinSymbol. Modify the symbol as required in WinSymbol. Save modification (Ctrl-S). Accept the modifications. Save the symbol in the '_MeasuringInstruments' library, naming it 'amperemeter # carre'. (Do not use accented characters to name symbols). It's very important to keep the same starting name, 'amperemeter' in the example, then add the ' # ' character followed by the name of your choice. The ' # ' symbol tells the simulator that the new 'carre' symbol is a variation of the 'amperemeter' symbol. Example 2 : We'd like to add a solenoid valve symbol to the family, which we'll call ' Solenoid_Valve#1 '. The operation takes longer than in the previous example, as the symbol's drawing must be created when it is active. Active symbol drawings are stored in the file : C:\\Users\\Public\\Documents\\Elec-CAO\\wrs-data\\wrs-on-symbols.xrs Place the ' Solenoid_Valve ' symbol from the ' _Coils' family on the folio. Modify the symbol as described in points 2.3 and 4 of example 1. Save the symbol in the '' _Coils '' library, naming it ' Solenoid_Valve#1 '. Open the schematic ' wrs-on-symbols.xrs' in WinRelais. Preferably select the '_Coils' folio. Place the newly saved symbol ' Solenoid_Valve#1 ' on the folio. Go to Modify Symbol. Modify the symbol as required in WinSymbol. Save modification (Ctrl-S). Accept the modifications. Save schematic as ' wrs-on-symbols.xrs '. Example 3 : Using a png image to create the visual for a solenoid valve, which will be named ' Solenoid_Valve#2 '. We may find that WinSymbol's drawing capabilities are not sufficient to create the visuals for the symbols. In this case, it's possible to use a texture that will be edited in a separate program. The visual of the initial 'electrovalve' object manipulated earlier is constructed with this texture: The texture must have the same name as the object. Place the ' Solenoid_Valve ' symbol of the ' _Coils' family on the folio. Save the symbol in the '' _Coils ' library, naming it ' Solenoid_Valve#2 '. Access the 'Solenoid_Valve.png' texture in the folder: C:\\Us\\Public\\Documents\\Elec-CAO\\wrs-data\\sym_textures\\_Coils\\Solenoid_Valve.png Copy the texture renamed to ' Solenoid_Valve#2.png' into the same folder. Edit the ' Solenoid_Valve#2.png' texture in a suitable program (e.g. GIMP) as required, then save (command 'Overwrite Solenoid_Valve#2.png' with GIMP). Drawing mode(s) by symbol family Drawing mode(s) by symbol family _Terminals Texture or WinSymbol _Buildings WinSymbol only _Buttons Texture or WinSymbol _Capacitors WinSymbol only _Circuit_breakers WinSymbol only _Coils Texture or WinSymbol _Contactors WinSymbol only _Control_Contacts Texture or WinSymbol _Cylinders WinSymbol only |_DC_Motors|WinSymbol only| |_Detectors|Texture or WinSymbol| |_Diodes|WinSymbol only| |_Disconnect_Switches|WinSymbol only| |_Fuse_Switches|WinSymbol only| |_Ground+Earth|WinSymbol only| |_Hmi|Texture or WinSymbol| |_Indicators|Texture or WinSymbol| |_Limit_Switches|Texture or WinSymbol| |_Logic|WinSymbol only| |_Machine_Safety|WinSymbol only| |_Magnetic_Relays|WinSymbol only| |_Measurement_Instruments|WinSymbol only| |_PLC|WinSymbol only| |_Pneumatic_Components|WinSymbol only| |_Resistors|WinSymbol only| |_Sensors|WinSymbol only| |_Sfc|WinSymbol only| |_Speed_Drives|WinSymbol only| |_Supplies|WinSymbol only| |_Synoptic|Texture or WinSymbol| |_Terminals|Texture or WinSymbol| |_Thermal_Relays|WinSymbol only| |_Transformers|WinSymbol only| |_Valves|WinSymbol only| A symbol with the default design mode 'WinSymbol' can be transformed into another symbol using WinSymbol only. A symbol with the default drawing mode 'Texture' can be transformed into another symbol with a modified texture, or with a WinSymbol description. General component settings (available in 'Modify an object' in WinRelais) Relay, Timer, Timer Library _Coils vn = coil voltage [12 to 230 V] pn = rated power [12 to 230 V] toff = deactivation delay [0 to 30 s] ton = activation delay [0 to 30 s] timed contacts library _contacts_commande toff = deactivation delay [0 to 30 s] ton = Activation delay [0 to 30 s] Signaling library _signaling v = coil voltage [12 to 230 V] color = LED color [red, green, blue, orange, white] circuit breaker + DDR library _circuit breakers In = calibre [0.5 to 100 A] delay = intentional delay [0 to 10000 ms] courbe = courbe de d\u00e9clenchement [B, C, D] idn = sensitivity of differential [10 to 10000 mA] diff_delay = intentional delay of the DDR [0 to 10000 ms] Fuse Library _fuse_sectionneurs_porte_fusibles In = fuse rating [0.5 to 100 A] delay = intentional delay [0 to 10000 ms] type = type of cartridge [aM, gG] Fuse library _relais_thermiques ith = thermal threshold [0.1 to 100 A] AC_motors library _alternative_engines Pu = motor output power [90 W to 22 kW] nm = nominal motor speed [740 to 3000 rpm] cos = cos(phi) motor [0.5 to 1] efficiency = motor efficiency [0.5 to 1] winding = rated voltage at winding terminals [127 to 400 V] coupling = - [star, triangle] DC_motors library _moteurs_continus pu = motor output power [90 W to 22 kW] nm = motor rated speed [740 to 3000 rpm] armature = armature voltage [12 to 320 V] efficiency = motor efficiency [0.5 to 1] source, stabilized power supply, transformer library \\ _sources pressure = compressed air pressure [0 to 10 bar] vin = input voltage [12 to 400 V] vout = output voltage [12 to 400 V] vout1 = output voltage [12 to 400 V] vout2 = output voltage [12 to 400 V] power resistors library _resistances pn = rated power [10 W to 22 kW] winding = nominal voltage at the terminals of a winding [230 or 400 V] Potentiometer library _resistances value = potentiometer resistance [1m to 10M ohms], (10m, 10, 10k, 2.2 M) alpha = position of slider [0 to 100 %] simple resistance library _resistances value = resistance [1m to 10M ohms], (10m, 10, 10k, 2.2 M) measuring_instruments library type = measurement type [avg, rms] display here position of measured value on folio * ditto that display here Electrical component labels: Symbols used in the simulation to indicate the status of electrical components: Armed electrical protection (circuit breaker and fuse) Electrical protection opening on overload or short-circuit (circuit breaker and fuse) Opening leakage current protection (DDR) Individual fuse cartridge status indicator. Example of a three-pole fuse holder with two fused cartridges. Receiver underpowered Receiver overpowered","title":"Simulable library"},{"location":"library/#simulable-library","text":"","title":"Simulable library"},{"location":"library/#access","text":"WinRelais exposes the library of simulatable components (folder D4) using three methods: The explorer provides easy access to the blocks_simulables folder, which can be used to retrieve complete simulation subsets:","title":"Access"},{"location":"library/#method-1-place-a-symbol","text":"","title":"Method 1: place a symbol"},{"location":"library/#method-2-search-and-place-a-symbol","text":"","title":"Method 2: search and place a symbol"},{"location":"library/#method-3-explore-and-place-a-symbol-using-drag-drop","text":"","title":"Method 3: explore and place a symbol using drag &amp; drop"},{"location":"library/#create-a-symbol-from-an-existing-symbol","text":"You can create a new symbol from an existing one, adapting its design and terminal layout as required. The new symbol inherits all the simulation logic of the parent symbol. The visual of the symbol can be defined with WinSymbol or with an image (also called texture) in png format. Constraints : Pin names must not be modified. The number of pins may not be changed. Example 1 : We want to create a square-shaped ammeter symbol. Place the 'amperemeter' symbol on the folio. Go to Modify a Symbol and select Run WinSymbol. Modify the symbol as required in WinSymbol. Save modification (Ctrl-S). Accept the modifications. Save the symbol in the '_MeasuringInstruments' library, naming it 'amperemeter # carre'. (Do not use accented characters to name symbols). It's very important to keep the same starting name, 'amperemeter' in the example, then add the ' # ' character followed by the name of your choice. The ' # ' symbol tells the simulator that the new 'carre' symbol is a variation of the 'amperemeter' symbol. Example 2 : We'd like to add a solenoid valve symbol to the family, which we'll call ' Solenoid_Valve#1 '. The operation takes longer than in the previous example, as the symbol's drawing must be created when it is active. Active symbol drawings are stored in the file : C:\\Users\\Public\\Documents\\Elec-CAO\\wrs-data\\wrs-on-symbols.xrs Place the ' Solenoid_Valve ' symbol from the ' _Coils' family on the folio. Modify the symbol as described in points 2.3 and 4 of example 1. Save the symbol in the '' _Coils '' library, naming it ' Solenoid_Valve#1 '. Open the schematic ' wrs-on-symbols.xrs' in WinRelais. Preferably select the '_Coils' folio. Place the newly saved symbol ' Solenoid_Valve#1 ' on the folio. Go to Modify Symbol. Modify the symbol as required in WinSymbol. Save modification (Ctrl-S). Accept the modifications. Save schematic as ' wrs-on-symbols.xrs '. Example 3 : Using a png image to create the visual for a solenoid valve, which will be named ' Solenoid_Valve#2 '. We may find that WinSymbol's drawing capabilities are not sufficient to create the visuals for the symbols. In this case, it's possible to use a texture that will be edited in a separate program. The visual of the initial 'electrovalve' object manipulated earlier is constructed with this texture: The texture must have the same name as the object. Place the ' Solenoid_Valve ' symbol of the ' _Coils' family on the folio. Save the symbol in the '' _Coils ' library, naming it ' Solenoid_Valve#2 '. Access the 'Solenoid_Valve.png' texture in the folder: C:\\Us\\Public\\Documents\\Elec-CAO\\wrs-data\\sym_textures\\_Coils\\Solenoid_Valve.png Copy the texture renamed to ' Solenoid_Valve#2.png' into the same folder. Edit the ' Solenoid_Valve#2.png' texture in a suitable program (e.g. GIMP) as required, then save (command 'Overwrite Solenoid_Valve#2.png' with GIMP).","title":"Create a symbol from an existing symbol"},{"location":"library/#drawing-modes-by-symbol-family","text":"Drawing mode(s) by symbol family _Terminals Texture or WinSymbol _Buildings WinSymbol only _Buttons Texture or WinSymbol _Capacitors WinSymbol only _Circuit_breakers WinSymbol only _Coils Texture or WinSymbol _Contactors WinSymbol only _Control_Contacts Texture or WinSymbol _Cylinders WinSymbol only |_DC_Motors|WinSymbol only| |_Detectors|Texture or WinSymbol| |_Diodes|WinSymbol only| |_Disconnect_Switches|WinSymbol only| |_Fuse_Switches|WinSymbol only| |_Ground+Earth|WinSymbol only| |_Hmi|Texture or WinSymbol| |_Indicators|Texture or WinSymbol| |_Limit_Switches|Texture or WinSymbol| |_Logic|WinSymbol only| |_Machine_Safety|WinSymbol only| |_Magnetic_Relays|WinSymbol only| |_Measurement_Instruments|WinSymbol only| |_PLC|WinSymbol only| |_Pneumatic_Components|WinSymbol only| |_Resistors|WinSymbol only| |_Sensors|WinSymbol only| |_Sfc|WinSymbol only| |_Speed_Drives|WinSymbol only| |_Supplies|WinSymbol only| |_Synoptic|Texture or WinSymbol| |_Terminals|Texture or WinSymbol| |_Thermal_Relays|WinSymbol only| |_Transformers|WinSymbol only| |_Valves|WinSymbol only| A symbol with the default design mode 'WinSymbol' can be transformed into another symbol using WinSymbol only. A symbol with the default drawing mode 'Texture' can be transformed into another symbol with a modified texture, or with a WinSymbol description.","title":"Drawing mode(s) by symbol family"},{"location":"library/#general-component-settings","text":"(available in 'Modify an object' in WinRelais) Relay, Timer, Timer Library _Coils vn = coil voltage [12 to 230 V] pn = rated power [12 to 230 V] toff = deactivation delay [0 to 30 s] ton = activation delay [0 to 30 s] timed contacts library _contacts_commande toff = deactivation delay [0 to 30 s] ton = Activation delay [0 to 30 s] Signaling library _signaling v = coil voltage [12 to 230 V] color = LED color [red, green, blue, orange, white] circuit breaker + DDR library _circuit breakers In = calibre [0.5 to 100 A] delay = intentional delay [0 to 10000 ms] courbe = courbe de d\u00e9clenchement [B, C, D] idn = sensitivity of differential [10 to 10000 mA] diff_delay = intentional delay of the DDR [0 to 10000 ms] Fuse Library _fuse_sectionneurs_porte_fusibles In = fuse rating [0.5 to 100 A] delay = intentional delay [0 to 10000 ms] type = type of cartridge [aM, gG] Fuse library _relais_thermiques ith = thermal threshold [0.1 to 100 A] AC_motors library _alternative_engines Pu = motor output power [90 W to 22 kW] nm = nominal motor speed [740 to 3000 rpm] cos = cos(phi) motor [0.5 to 1] efficiency = motor efficiency [0.5 to 1] winding = rated voltage at winding terminals [127 to 400 V] coupling = - [star, triangle] DC_motors library _moteurs_continus pu = motor output power [90 W to 22 kW] nm = motor rated speed [740 to 3000 rpm] armature = armature voltage [12 to 320 V] efficiency = motor efficiency [0.5 to 1] source, stabilized power supply, transformer library \\ _sources pressure = compressed air pressure [0 to 10 bar] vin = input voltage [12 to 400 V] vout = output voltage [12 to 400 V] vout1 = output voltage [12 to 400 V] vout2 = output voltage [12 to 400 V] power resistors library _resistances pn = rated power [10 W to 22 kW] winding = nominal voltage at the terminals of a winding [230 or 400 V] Potentiometer library _resistances value = potentiometer resistance [1m to 10M ohms], (10m, 10, 10k, 2.2 M) alpha = position of slider [0 to 100 %] simple resistance library _resistances value = resistance [1m to 10M ohms], (10m, 10, 10k, 2.2 M) measuring_instruments library type = measurement type [avg, rms] display here position of measured value on folio * ditto that display here","title":"General component settings"},{"location":"library/#electrical-component-labels","text":"Symbols used in the simulation to indicate the status of electrical components: Armed electrical protection (circuit breaker and fuse) Electrical protection opening on overload or short-circuit (circuit breaker and fuse) Opening leakage current protection (DDR) Individual fuse cartridge status indicator. Example of a three-pole fuse holder with two fused cartridges. Receiver underpowered Receiver overpowered","title":"Electrical component labels:"},{"location":"modbus/","text":"Modbus/Tcp-IP Preamble The simulator integrates the MODBUS/TCP-IP fieldbus protocol, a variant of the serial MODBUS proposed by MODICON since 1979. The TCP-IP variant encapsulates the MODBUS protocol in the Ethernet protocol. This encapsulation enables manufacturers to use MODBUS on any Ethernet hardware infrastructure. MODBUS TCP-IP offers decisive advantages: it's the most widely used Industrial Ethernet protocol in the world, its specifications are readily available, it is ideally suited to the rapid exchange of small quantities of data. MODBUS function codes supported code 03 (0x03) Read Holding Registers This function code is used to read the contents of a contiguous block of PLC memory registers. The request specifies the start register address and the number of registers. In the request, registers are addressed starting from zero. Thus, registers numbered 1 to 16 are addressed as 0 to 15. Register data in the response message is compacted as two bytes per register, with the binary content right-justified within each byte. For each register, the first byte contains the most significant bits and the second contains the least significant bits. code 16 (0x10) Write Multiple Registers This function code is used to write a block of contiguous registers (1 to 123 registers) to PLC memory, specifying the values to be written in the request data field. The data is compacted to two bytes per register. The normal response returns the function code, the start address and the number of registers written. code 23 (0x17) Read/Write Multiple Registers This function code performs a combination of read and write operations in a single MODBUS transaction. The write operation is performed before the read operation. PLC memory registers are addressed starting from zero. Thus, registers 1 to 16 are addressed in the PLC as 0 to 15. The request specifies the start address and number of PLC registers to be read, as well as the start address, number of PLC registers and data to be written. The WriteByteCount field specifies the number of bytes that follow in the data field to be written. The normal response contains the data from the group of registers that have been read. The ByteCount field specifies the number of bytes to follow in the read data field. MODBUS mapping MODBUS Configuration ip_adress localhost/127.0.0.1/xxx.xxx.xxx.xxx IP address of PLC server port 502 standard MODBUS port unit_ID 111 customer_id exchange_table_address 400 pointer on exchange table If the MODBUS configuration object is not set in your project, the default values used are: ip_address = local_host, port = 502, exchange_table_address = 400 and unit_ID = 111. The MODBUS configuration object is only required when a PLC is present in a folio.","title":"Modbus TCP-IP"},{"location":"modbus/#modbustcp-ip","text":"","title":"Modbus/Tcp-IP"},{"location":"modbus/#preamble","text":"The simulator integrates the MODBUS/TCP-IP fieldbus protocol, a variant of the serial MODBUS proposed by MODICON since 1979. The TCP-IP variant encapsulates the MODBUS protocol in the Ethernet protocol. This encapsulation enables manufacturers to use MODBUS on any Ethernet hardware infrastructure. MODBUS TCP-IP offers decisive advantages: it's the most widely used Industrial Ethernet protocol in the world, its specifications are readily available, it is ideally suited to the rapid exchange of small quantities of data.","title":"Preamble"},{"location":"modbus/#modbus-function-codes-supported","text":"code 03 (0x03) Read Holding Registers This function code is used to read the contents of a contiguous block of PLC memory registers. The request specifies the start register address and the number of registers. In the request, registers are addressed starting from zero. Thus, registers numbered 1 to 16 are addressed as 0 to 15. Register data in the response message is compacted as two bytes per register, with the binary content right-justified within each byte. For each register, the first byte contains the most significant bits and the second contains the least significant bits. code 16 (0x10) Write Multiple Registers This function code is used to write a block of contiguous registers (1 to 123 registers) to PLC memory, specifying the values to be written in the request data field. The data is compacted to two bytes per register. The normal response returns the function code, the start address and the number of registers written. code 23 (0x17) Read/Write Multiple Registers This function code performs a combination of read and write operations in a single MODBUS transaction. The write operation is performed before the read operation. PLC memory registers are addressed starting from zero. Thus, registers 1 to 16 are addressed in the PLC as 0 to 15. The request specifies the start address and number of PLC registers to be read, as well as the start address, number of PLC registers and data to be written. The WriteByteCount field specifies the number of bytes that follow in the data field to be written. The normal response contains the data from the group of registers that have been read. The ByteCount field specifies the number of bytes to follow in the read data field.","title":"MODBUS function codes supported"},{"location":"modbus/#modbus-mapping","text":"","title":"MODBUS mapping"},{"location":"modbus/#modbus-configuration","text":"ip_adress localhost/127.0.0.1/xxx.xxx.xxx.xxx IP address of PLC server port 502 standard MODBUS port unit_ID 111 customer_id exchange_table_address 400 pointer on exchange table If the MODBUS configuration object is not set in your project, the default values used are: ip_address = local_host, port = 502, exchange_table_address = 400 and unit_ID = 111. The MODBUS configuration object is only required when a PLC is present in a folio.","title":"MODBUS Configuration"},{"location":"plc/","text":"Programmable Logic Controller Preamble The simulator integrates a physical or virtual PLC into a folio. Communication with the PLC is carried out using the [Modbus/Tcp-IP] protocol (modbus.md) : with the local IP address (127.0.0.1) of the Modbus server integrated into the virtual PLC, with the static IP address of the Modbus server integrated into the physical PLC connected to an Ethernet network. This solution makes it possible to use the usual PLC programming tools. Exchange logic client (master) (simulator) <-> server (slave) (api) , periodically : the Modbus client (simulator) sends a request to write the simulated SAP inputs to the Modbus server (PLC), the PLC calculates the state of the SAP outputs according to its program and the state of the inputs received, the Modbus client (simulator) sends a request to read the outputs calculated by the program to the Modbus server (PLC), the simulator updates the SAP status. PLCs tested : M221 Schneider Electric function codes 3,16 and 23, integrated Modbus server M340** Schneider Electric function codes 3 and 16, integrated modbus server Unilogic** Unitronics function codes 3,16 and 23, Modbus server configuration required: The example below uses EcoStruxure Basic Expert from SchneiderElectric to program and simulate M221 family PLCs. Elevator example (fichiers us15 - demo_elevator_M221.xrs et us15 - demo_elevator_M221.smbp) WRsimulator Preparation : Elevator control requires 8 digital inputs and 4 digital outputs. An M221 type TM221CE16R can be used, with 9 digital inputs and 7 relay outputs. Addressing of digital inputs: %I0.0, %I0.1, %I0.2, %I0.3, %I0.4, %I0.5, %I0.6, %I0.7, %I0.8 Output addressing: %Q0.0, %Q0.1, %Q0.2, %Q0.3, %Q0.4, %Q0.5, %Q0.6 This example implements 8 input objects and 4 output objects, identifying them with standard PLC addresses. Input assignment address mnemonic comment %I0.0 E3 appel \u00e9tage 3 %I0.1 E2 appel \u00e9tage 2 %I0.2 E1 appel \u00e9tage 1 %I0.3 P1 cabine \u00e0 l\u00e9tage 1 %I0.4 P2 cabine \u00e0 l\u00e9tage 2 %I0.5 P3 cabine \u00e0 l\u00e9tage 3 %I0.6 PF porte cabine ferm\u00e9e %I0.7 PO porte cabine ouverte Output assignment address mnemonic comment %Q0.0 OUVRIR Open door %Q0.1 FERMER Close door %Q0.2 DESCENDRE go down cab %Q0.3 MONTER go up cab Preparation side EcoStruxure Machine Expert--Basic The complete program us15 - demo_elevator_M221.smbp is available in the : Mapping of input/output tables to the exchange table set at start address %MW400 see modbus mapping : adress MODBUS mapping mnemonic comment %I0.0 %MW500 :X0 E3 call stage 3 %I0.1 %MW500 :X1 E2 call stage 2 %I0.2 %MW500 :X2 E1 call stage 1 %I0.3 %MW500 :X3 P1 elevator cab on floor 1 %I0.4 %MW500 :X4 P2 elevator cab on floor 2 %I0.5 %MW500 :X5 P3 elevator cab on floor 3 %I0.6 %MW500 :X6 PF cab door closed %I0.7 %MW500 :X7 PO cab door open adress MODBUS mapping mnemonic comment %Q0.0 %MW400 :X0 OUVRIR Open cab door %Q0.1 %MW400 :X1 FERMER Close cab door %Q0.2 %MW400 :X2 DESCENDRE go down cab %Q0.3 %MW401 :X3 MONTER go up cab In the Programming ->Tools ->Symbols list tab, you'll find the input/output assignments that correspond to the tables above: PLC program : Start the controller BEFORE starting the simulator by activating the Start simulation and Start controller buttons in the EcoStruxure commissioning tab. Building a PLC object A PLC is built with the elementary objects : input# for digital inputs, output# for digital outputs, analog_input# for analog inputs, analog_output# for analog outputs, plc_supply# for PLC power supply. All I/Os have the plc_supply object as their parent, in order to link the supply of these I/Os to the PLC power supply. The MODBUS server is implicitly attached to the PLC in place in the schematic. Only one PLC can be placed in the schematic. Examples of PLCs are available in the folder blocs_simulables , using the WinRelais command 'Open a block'. All these automaton footprints can be adjusted and modified as required. Entr\u00e9es/Sorties logiques input, output library _api %Ir.v or %Qr.v r = [0,5] v = [0,31] parent = object name plc_supply# Analog inputs analog_input library _api %IWr.v r = [0,5] v = [0,3] parent = object name plc_supply# input_type = U ou I input_range = (min,max) V [-10,10] V or (min,max) mA [0, 20] mA input_scale = min,max [-32768, 32767] Analog Outputs analog_output library _api %QW0.0 r = [0,5] v = [0,3] parent = object name plc_supply# output_type = U or I output_range = (min,max) V [-10,10] V or (min,max) mA [0, 20] mA output_scale = min,max [-32768, 32767]","title":"Programmable Logic Controller"},{"location":"plc/#programmable-logic-controller","text":"","title":"Programmable Logic Controller"},{"location":"plc/#preamble","text":"The simulator integrates a physical or virtual PLC into a folio. Communication with the PLC is carried out using the [Modbus/Tcp-IP] protocol (modbus.md) : with the local IP address (127.0.0.1) of the Modbus server integrated into the virtual PLC, with the static IP address of the Modbus server integrated into the physical PLC connected to an Ethernet network. This solution makes it possible to use the usual PLC programming tools. Exchange logic client (master) (simulator) <-> server (slave) (api) , periodically : the Modbus client (simulator) sends a request to write the simulated SAP inputs to the Modbus server (PLC), the PLC calculates the state of the SAP outputs according to its program and the state of the inputs received, the Modbus client (simulator) sends a request to read the outputs calculated by the program to the Modbus server (PLC), the simulator updates the SAP status. PLCs tested : M221 Schneider Electric function codes 3,16 and 23, integrated Modbus server M340** Schneider Electric function codes 3 and 16, integrated modbus server Unilogic** Unitronics function codes 3,16 and 23, Modbus server configuration required: The example below uses EcoStruxure Basic Expert from SchneiderElectric to program and simulate M221 family PLCs.","title":"Preamble"},{"location":"plc/#elevator-example","text":"(fichiers us15 - demo_elevator_M221.xrs et us15 - demo_elevator_M221.smbp)","title":"Elevator example"},{"location":"plc/#wrsimulator-preparation","text":"Elevator control requires 8 digital inputs and 4 digital outputs. An M221 type TM221CE16R can be used, with 9 digital inputs and 7 relay outputs. Addressing of digital inputs: %I0.0, %I0.1, %I0.2, %I0.3, %I0.4, %I0.5, %I0.6, %I0.7, %I0.8 Output addressing: %Q0.0, %Q0.1, %Q0.2, %Q0.3, %Q0.4, %Q0.5, %Q0.6 This example implements 8 input objects and 4 output objects, identifying them with standard PLC addresses. Input assignment address mnemonic comment %I0.0 E3 appel \u00e9tage 3 %I0.1 E2 appel \u00e9tage 2 %I0.2 E1 appel \u00e9tage 1 %I0.3 P1 cabine \u00e0 l\u00e9tage 1 %I0.4 P2 cabine \u00e0 l\u00e9tage 2 %I0.5 P3 cabine \u00e0 l\u00e9tage 3 %I0.6 PF porte cabine ferm\u00e9e %I0.7 PO porte cabine ouverte Output assignment address mnemonic comment %Q0.0 OUVRIR Open door %Q0.1 FERMER Close door %Q0.2 DESCENDRE go down cab %Q0.3 MONTER go up cab","title":"WRsimulator Preparation :"},{"location":"plc/#preparation-side-ecostruxure-machine-expert-basic","text":"The complete program us15 - demo_elevator_M221.smbp is available in the : Mapping of input/output tables to the exchange table set at start address %MW400 see modbus mapping : adress MODBUS mapping mnemonic comment %I0.0 %MW500 :X0 E3 call stage 3 %I0.1 %MW500 :X1 E2 call stage 2 %I0.2 %MW500 :X2 E1 call stage 1 %I0.3 %MW500 :X3 P1 elevator cab on floor 1 %I0.4 %MW500 :X4 P2 elevator cab on floor 2 %I0.5 %MW500 :X5 P3 elevator cab on floor 3 %I0.6 %MW500 :X6 PF cab door closed %I0.7 %MW500 :X7 PO cab door open adress MODBUS mapping mnemonic comment %Q0.0 %MW400 :X0 OUVRIR Open cab door %Q0.1 %MW400 :X1 FERMER Close cab door %Q0.2 %MW400 :X2 DESCENDRE go down cab %Q0.3 %MW401 :X3 MONTER go up cab In the Programming ->Tools ->Symbols list tab, you'll find the input/output assignments that correspond to the tables above: PLC program : Start the controller BEFORE starting the simulator by activating the Start simulation and Start controller buttons in the EcoStruxure commissioning tab.","title":"Preparation side EcoStruxure Machine Expert--Basic"},{"location":"plc/#building-a-plc-object","text":"A PLC is built with the elementary objects : input# for digital inputs, output# for digital outputs, analog_input# for analog inputs, analog_output# for analog outputs, plc_supply# for PLC power supply. All I/Os have the plc_supply object as their parent, in order to link the supply of these I/Os to the PLC power supply. The MODBUS server is implicitly attached to the PLC in place in the schematic. Only one PLC can be placed in the schematic. Examples of PLCs are available in the folder blocs_simulables , using the WinRelais command 'Open a block'. All these automaton footprints can be adjusted and modified as required.","title":"Building a PLC object"},{"location":"plc/#entreessorties-logiques","text":"input, output library _api %Ir.v or %Qr.v r = [0,5] v = [0,31] parent = object name plc_supply#","title":"Entr\u00e9es/Sorties logiques"},{"location":"plc/#analog-inputs","text":"analog_input library _api %IWr.v r = [0,5] v = [0,3] parent = object name plc_supply# input_type = U ou I input_range = (min,max) V [-10,10] V or (min,max) mA [0, 20] mA input_scale = min,max [-32768, 32767]","title":"Analog inputs"},{"location":"plc/#analog-outputs","text":"analog_output library _api %QW0.0 r = [0,5] v = [0,3] parent = object name plc_supply# output_type = U or I output_range = (min,max) V [-10,10] V or (min,max) mA [0, 20] mA output_scale = min,max [-32768, 32767]","title":"Analog Outputs"},{"location":"simulator/","text":"Simulator WinRelay integration The simulator is active by default. Activation sets WinRelais to the following parameters ( Tools/Options ) : The k key displays/hides textures applied to simulatable objects: To launch the simulator, click on the icon: right-click on a simulable object to : edit its properties, rotate synoptic and cylinder objects to the nearest degree. Restrictions Numerical Model Mechanical loads applied to actuators (cylinders, motors) are fixed. They correspond to the actuators' nominal operating point. Current and voltage transients are not simulated. The maximum acquisition frequency of the measuring equipment is limited to 50Hz (1 measurement every 20 ms). Measurements are given in RMS or mean value only. drawing editing At present, there is no 'tool' for converting previous schematics into simulable schematics. Line width for conductors is fixed. Only the 'Arial' font is supported. Left' text alignment only. Bold and italic characters are transformed into normal characters. Frames and leaflets are not drawn in the simulator. Only one symbol size can be used: 'normal'. Editing symbols in WinSymbol Some of the graphical features offered by WinSymbol are not taken into account by the simulator: - No B\u00e9zier curve, no text, unfilled circle only, - Fixed contour thickness - No SVG graphics - No background image - No mini-drawings. Symbol editing anomaly Occasionally, when a symbol is rotated in WinRelais, the collision texture and shape may shift. In this case, it is necessary to re-center the symbol's origin in WinSymbol. the symbol origin in WinSymbol (see page 17 on the question of the barycentre). It is preferable to carry out the rotation in WinSymbol, carefully adjust the barycenter and then save the symbol for reuse. General configuration blocks This block adjusts certain display details of the current folio, and is mainly used for fine-tuning purposes: collisions = (False/True): displays collision patterns of physical objects, sensors_collisions = (False/True) : displays collision shapes of sensors and limit switches, wrs_equips** = (False/True): displays equipotential numbers defined by the simulator, wr_equips** = (False/True) : displays equipotential numbers defined in WinRelais, terminals_nums** = (False/True) : displays device terminal numbers. The World_Settings blocks define the behavior of the 2D physics engine. It is possible to adjust the motor in : - Top view: gravity is not taken into account, - Side view: gravity is taken into account. Only one World_Settings block can be placed per folio. It is possible to have different views from one folio to another, for example : - one folio with a physical space described in top view, - the next folio with a physical space described in side view. The ' damping ' coefficient, between 0 and 1, simulates air friction on a moving object.","title":"Simulator"},{"location":"simulator/#simulator","text":"","title":"Simulator"},{"location":"simulator/#winrelay-integration","text":"The simulator is active by default. Activation sets WinRelais to the following parameters ( Tools/Options ) : The k key displays/hides textures applied to simulatable objects: To launch the simulator, click on the icon: right-click on a simulable object to : edit its properties, rotate synoptic and cylinder objects to the nearest degree.","title":"WinRelay integration"},{"location":"simulator/#restrictions","text":"","title":"Restrictions"},{"location":"simulator/#numerical-model","text":"Mechanical loads applied to actuators (cylinders, motors) are fixed. They correspond to the actuators' nominal operating point. Current and voltage transients are not simulated. The maximum acquisition frequency of the measuring equipment is limited to 50Hz (1 measurement every 20 ms). Measurements are given in RMS or mean value only.","title":"Numerical Model"},{"location":"simulator/#drawing-editing","text":"At present, there is no 'tool' for converting previous schematics into simulable schematics. Line width for conductors is fixed. Only the 'Arial' font is supported. Left' text alignment only. Bold and italic characters are transformed into normal characters. Frames and leaflets are not drawn in the simulator. Only one symbol size can be used: 'normal'.","title":"drawing editing"},{"location":"simulator/#editing-symbols-in-winsymbol","text":"Some of the graphical features offered by WinSymbol are not taken into account by the simulator: - No B\u00e9zier curve, no text, unfilled circle only, - Fixed contour thickness - No SVG graphics - No background image - No mini-drawings.","title":"Editing symbols in WinSymbol"},{"location":"simulator/#symbol-editing-anomaly","text":"Occasionally, when a symbol is rotated in WinRelais, the collision texture and shape may shift. In this case, it is necessary to re-center the symbol's origin in WinSymbol. the symbol origin in WinSymbol (see page 17 on the question of the barycentre). It is preferable to carry out the rotation in WinSymbol, carefully adjust the barycenter and then save the symbol for reuse.","title":"Symbol editing anomaly"},{"location":"simulator/#general-configuration-blocks","text":"This block adjusts certain display details of the current folio, and is mainly used for fine-tuning purposes: collisions = (False/True): displays collision patterns of physical objects, sensors_collisions = (False/True) : displays collision shapes of sensors and limit switches, wrs_equips** = (False/True): displays equipotential numbers defined by the simulator, wr_equips** = (False/True) : displays equipotential numbers defined in WinRelais, terminals_nums** = (False/True) : displays device terminal numbers. The World_Settings blocks define the behavior of the 2D physics engine. It is possible to adjust the motor in : - Top view: gravity is not taken into account, - Side view: gravity is taken into account. Only one World_Settings block can be placed per folio. It is possible to have different views from one folio to another, for example : - one folio with a physical space described in top view, - the next folio with a physical space described in side view. The ' damping ' coefficient, between 0 and 1, simulates air friction on a moving object.","title":"General configuration blocks"},{"location":"speed_controller/","text":"Speed controller Preamble WRsimulator can be used to insert variable speed drives into folios. The library currently includes SchneiderElectric ATV31 single-phase and three-phase drive objects. Example 18-demo_variateurATV31 illustrates the use of an ATV31 drive to control the speed of a moving table. - the drive is attached to a text zone edited in WinRelais, which specifies its parameters, - The first line of the text zone must begin with the command : - parent = drive name, - This text zone can be placed anywhere in the diagram, - If the text field does not exist, the drive is set to default parameters. ATV31 settings ATV31_programming_manual_FR_1624588_04.pdf Default settings Description In = 10 Inverter calibration bFr = 50 Standard motor frequency [50,60] ItH = 10.0 Motor thermal protection [0.2 to 1.5 In] CLI = 15.0 Current limitation [0.25 to 1.5 In] ACC = 3.0 Acceleration ramp time [0.1 to 3276 s] dEC = 3.0 Deceleration ramp time [0.1 to 3276 s] LSP = 0 Low speed [0 Hz to HSP] HSP = 50 High speed [LSP to bFR] PS2 = n0 2 preset speeds [n0,LI3,LI4,LI5,LI6] PS4 = n0 4 preselected speeds [n0,LI3,LI4,LI5,LI6] PS8 = n0 8 preselected speeds [n0,LI3,LI4,LI5,LI6] SP2 = 10 Preset speed 2 [0 Hz to HSP] SP3 = 15 Preset speed 3 [0 Hz to HSP] SP4 = 20 Preset speed 4 [0 Hz to HSP] SP5 = 25 Preset speed 5 [0 Hz to HSP] SP6 = 30 Preset speed 6 [0 Hz to HSP] SP7 = 35 Preset speed 7 [0 Hz to HSP] SP8 = 40 Preset speed 8 [0 Hz to HSP] tCC = 2C Control 2wire / 3wire [2C, 3C] tCt = trn Control type 2wire [LEL, trn, PFO] r1 = FLt Relay r1 [n0,FLt,rUn,FtA,FLA,CtA,SrA,tSA,APL,LI1,LI2,LI3,LI4,LI5,LI6] r2 = n0 Relay r2 [n0,FLt,rUn,FtA,FLA,CtA,SrA,tSA,bLC,APL,LI1,LI2,LI3,LI4,LI5,LI6] FSt = n0 Fast stop on logic 0 [n0, LI1, LI2, LI3, LI4, LI5, LI6] LAF = n0 Forward limit switch [n0, LI1, LI2, LI3, LI4, LI5, LI6] LAr = n0 Stroke end forward [n0, LI1, LI2, LI3, LI4, LI5,LI6] LAS = nSt Stop type at end of stroke [rMP, FSt, nSt] FR1 = AII Setpoint 1 configuration [AII, AI2, AI3] ATV11 settings ATV11_UserManual.pdf default settings Description In = 10 Inverter calibration bFr = 50 Standard motor frequency [50,60] ItH = 10.0 Motor thermal protection [0.2 to 1.5 In] CLI = 15.0 Current limitation [0.25 to 1.5 In] ACC = 3.0 Acceleration ramp time [0.1 to 3276 s] dEC = 3.0 Deceleration ramp time [0.1 to 3276 s] LSP = 0 Low speed [0 Hz to HSP] HSP = 50 High speed [LSP to bFR] SP2 = 10 Preset speed 2 [0 Hz to HSP] SP3 = 25 Preset speed 3 [0 Hz to HSP] SP4 = 50 Preset speed 4 [0 Hz to HSP] Alt = 5U Analog input configuration [5U, 10U, 0A, 4A] ACt = 2C 2-wire / 3-wire control [2C, 3C] tCt = trn 2-wire control type [LEL, trn, PFO] rrS = n0 Rear direction [n0,LII,LI2,LI3,LI4] LIA = n0 LIA input assignment [n0,LII,LI2,LI3,LI4] LIb = n0 Input assignment LIb [n0,LII,LI2,LI3,LI4] dO = n0 [n0, 0Cr, rFr, FtA, SrA CtA] Ftd = 50 Threshold frequency (0 to 200 Hz) Ctd = 10 Current threshold [0 to 1.5 In]","title":"Speed Controller"},{"location":"speed_controller/#speed-controller","text":"","title":"Speed controller"},{"location":"speed_controller/#preamble","text":"WRsimulator can be used to insert variable speed drives into folios. The library currently includes SchneiderElectric ATV31 single-phase and three-phase drive objects. Example 18-demo_variateurATV31 illustrates the use of an ATV31 drive to control the speed of a moving table. - the drive is attached to a text zone edited in WinRelais, which specifies its parameters, - The first line of the text zone must begin with the command : - parent = drive name, - This text zone can be placed anywhere in the diagram, - If the text field does not exist, the drive is set to default parameters.","title":"Preamble"},{"location":"speed_controller/#atv31-settings","text":"ATV31_programming_manual_FR_1624588_04.pdf Default settings Description In = 10 Inverter calibration bFr = 50 Standard motor frequency [50,60] ItH = 10.0 Motor thermal protection [0.2 to 1.5 In] CLI = 15.0 Current limitation [0.25 to 1.5 In] ACC = 3.0 Acceleration ramp time [0.1 to 3276 s] dEC = 3.0 Deceleration ramp time [0.1 to 3276 s] LSP = 0 Low speed [0 Hz to HSP] HSP = 50 High speed [LSP to bFR] PS2 = n0 2 preset speeds [n0,LI3,LI4,LI5,LI6] PS4 = n0 4 preselected speeds [n0,LI3,LI4,LI5,LI6] PS8 = n0 8 preselected speeds [n0,LI3,LI4,LI5,LI6] SP2 = 10 Preset speed 2 [0 Hz to HSP] SP3 = 15 Preset speed 3 [0 Hz to HSP] SP4 = 20 Preset speed 4 [0 Hz to HSP] SP5 = 25 Preset speed 5 [0 Hz to HSP] SP6 = 30 Preset speed 6 [0 Hz to HSP] SP7 = 35 Preset speed 7 [0 Hz to HSP] SP8 = 40 Preset speed 8 [0 Hz to HSP] tCC = 2C Control 2wire / 3wire [2C, 3C] tCt = trn Control type 2wire [LEL, trn, PFO] r1 = FLt Relay r1 [n0,FLt,rUn,FtA,FLA,CtA,SrA,tSA,APL,LI1,LI2,LI3,LI4,LI5,LI6] r2 = n0 Relay r2 [n0,FLt,rUn,FtA,FLA,CtA,SrA,tSA,bLC,APL,LI1,LI2,LI3,LI4,LI5,LI6] FSt = n0 Fast stop on logic 0 [n0, LI1, LI2, LI3, LI4, LI5, LI6] LAF = n0 Forward limit switch [n0, LI1, LI2, LI3, LI4, LI5, LI6] LAr = n0 Stroke end forward [n0, LI1, LI2, LI3, LI4, LI5,LI6] LAS = nSt Stop type at end of stroke [rMP, FSt, nSt] FR1 = AII Setpoint 1 configuration [AII, AI2, AI3]","title":"ATV31 settings"},{"location":"speed_controller/#atv11-settings","text":"ATV11_UserManual.pdf default settings Description In = 10 Inverter calibration bFr = 50 Standard motor frequency [50,60] ItH = 10.0 Motor thermal protection [0.2 to 1.5 In] CLI = 15.0 Current limitation [0.25 to 1.5 In] ACC = 3.0 Acceleration ramp time [0.1 to 3276 s] dEC = 3.0 Deceleration ramp time [0.1 to 3276 s] LSP = 0 Low speed [0 Hz to HSP] HSP = 50 High speed [LSP to bFR] SP2 = 10 Preset speed 2 [0 Hz to HSP] SP3 = 25 Preset speed 3 [0 Hz to HSP] SP4 = 50 Preset speed 4 [0 Hz to HSP] Alt = 5U Analog input configuration [5U, 10U, 0A, 4A] ACt = 2C 2-wire / 3-wire control [2C, 3C] tCt = trn 2-wire control type [LEL, trn, PFO] rrS = n0 Rear direction [n0,LII,LI2,LI3,LI4] LIA = n0 LIA input assignment [n0,LII,LI2,LI3,LI4] LIb = n0 Input assignment LIb [n0,LII,LI2,LI3,LI4] dO = n0 [n0, 0Cr, rFr, FtA, SrA CtA] Ftd = 50 Threshold frequency (0 to 200 Hz) Ctd = 10 Current threshold [0 to 1.5 In]","title":"ATV11 settings"},{"location":"synoptic/","text":"Synoptic Preamble The simulator allows you to create small operative parts that can be controlled with the actuators of the schematic. It integrates a 2D physics engine to bring a certain realism to the simulation. Example: This example shows two cylindrical drums on an inclined ramp, seen from the side. When the cylinder rod extends, the two drums are raised to the top of the ramp. When the cylinder rod retracts, the two drums roll (or slide, depending on the coefficient of friction applied) down the ramp, finally being locked in position by the cylinder nose. Two types of objects are used by the physical motor: - physical objects, which are subject to external forces and gravity. In particular, they have a mass in kilograms - kinematic objects, whose positions in the scene are controlled directly by the program. They are insensitive to external forces and therefore not subject to the laws of physics. Physical objects can collide with kinematic objects. Physical object settings |shape|library|Physics| | ---------------| ----------------------------------------------------------------------------------------| |dynamic =| True -> object is of type 'physical', False -> object is of type 'kinematic'| |masse =| mass in kg of the physical object [1 to 100 kg]| |friction =| coefficient of friction [0 to 100] applied to the physical object| |pas_de_rotation =| applies a considerable mass and inertia value to the physical object| |id_collision =| * (default value)| |texture_name =|image name ( png format only)| - if dynamics = False, parameters mass and friction are ignored. Kinematic object settings |kinematic|library|_Synoptic| | ---------------| ----------------------------------------------------------------------------------------| |parent =|designates a parent that can only be a sliding link| |id_collision =| * (default value)| |texture_name =|name of the image that can be applied to the object ( png format only)| |show =|True (False or True) show/hide object| - A kinematic object can be attached to a sliding link. - The show parameter allows the use of invisible 'walls'. Detector and limit switch Detects physical and kinematic objects that enter the sensor/end-of-travel detection zone - A sensor is a specialized kinematic object available in the _Synoptique library. |sensor|library|_Synoptic| |-----------|--------------------------------------| |parent =| designates a parent that can only be a sliding link| |id_collision =| * (default value, detects all objects present in the detection zone)| |texture_name =|name of the image that can be applied to the object ( png format only)| | =|fixes the position of the indicator light (green square)| =|fixes the position of the indicator light (green square) A detector with id_collision = * detects all objects entering its detection zone. id_collision** is used to filter objects detected by a detector or limit switch component. For example : |Collision Object Filtering| | ----------------------------------------------| |sensor A detects only object P2| |sensor * detects objects P1, P2 and P3| |sensor B detects only object P3| - A sensor's detection zone is defined by a magenta (255,0,255) color contour. (255,0,255) . For example : If a texture name is defined, the application searches for the texture (in png format only) in the folder C:\\Users\\Public\\Documents\\Elec-CAO\\wrs-data\\textures If the texture name is not defined, or if the texture file is not found, a texture calculated by the program will be applied to the object using the outer edge coloured red . For example: The texture silhouette automatically defines the object's collision shape. - The physics engine uses the transparent part of the texture to delimit the collision shape in the form of a convex polygon, as shown below: Drawing constraint in WinSymbol . Slider links Slider links are available in the _Synoptique library and are prefixed with the slider keyword: Description of slider parameters: |slider |library|_Synoptic| | ---------------| ----------------------------------------------------------------------------------------| |controle_direction =| designates the motor object used to control the mobile in direction| |speed_control =| designates the motor object used to control the mobile in speed| |speed =|speed in % of motor speed (transcribed as linear speed). [0 \u00e0100%]| |friction =|fixes the friction of the motor surface [0 to 100]| |id_collision =| * (default value, detects any object that collides)| |parent =| designates a parent which can only be another sliding link| |texture_name =| name of the texture that can be applied to the mobile. Elements of a sliding connection that can be edited in WinSymbol : These elements are differentiated in WinSymbol by specific colors: - (255,128,255) identifies the guideline and limits of movement (square and circle symbols), - (255,0,0) identifies the outer contour of the mobile. This contour must be a single convex polygon, - (255,0,255) identifies the optional collision shape, which must be a single convex polygon. If this polygon is not defined, the physics engine calculates the collision shape from the red outer contour. Examples Cylinder actuator A cylinder is a specialized sliding link. VerinSE, VerinDE library _Verins pressure = nominal pressure [0 to 10 bar] speed = speed coefficient of rod movement [0 to 100%] id_collision = * (default value, detects any object colliding with it) texture_name = name of texture that can be applied to the rod Floating cylinder actuator Identical to the cylinder component, except that it can be attached to a sliding link. It is systematically associated with : a Label_Pression object for single-acting cylinders, two Label_Pression objects for double-acting cylinders. The names of Label_Pression objects are used in the float_inputs (or float_input ) parameter to connect cylinder ports. VerinDE_flottant library _Verins float_inputs = (Label_Pression orifice 1, Label_Pression orifice 2) parent = designates a parent which may be just another slide link pressure = nominal pressure [0 to 10 bar] speed = speed coefficient of rod movement [0 to 100%] id_collision = * (default value, detects any object colliding with it) texture_name = name of the texture that can be applied to the rod VerinSE_flottant library _Verins float_input = Label_Pression orifice 1 parent = designates a parent which may be just another slide link. pressure = nominal pressure [0 to 10 bar] speed = speed coefficient of rod displacement Sliding link and kinship All kinematic objects can be attached to a sliding link. This is extremely useful for creating non-convex collision shapes, for example : The rod nose is a kinematic object attached to the cylinder rod through the parent parameter : Several kinematic objects can be attached: Top view conveyor Top-view conveyors are available in the _Synoptique library and are prefixed with the conveyor keyword: conveyor library \\_Synoptic controle_direction = motor object used to control conveyor diection control_speed = motor object used to control speed speed = conveyor speed as % of motor speed (transcribed as linear speed). [0 \u00e0 100%] friction = fixes conveyor friction [0 to 100] id_collision = * (default value) parent = designates a parent that can only be a sliding link texture_name = name of the texture that can be applied to the conveyor Side view conveyor Side-view conveyors are available in the _Synoptique library and are prefixed with the side_conveyor keyword: side_conveyor library \\_Synoptic control_direction = motor object used to control conveyor diection speed_control = motor object used to control speed speed = conveyor speed as % of motor speed (transcribed as linear speed). [0 \u00e0 100%] friction = fixes conveyor friction [0 to 100] id_collision = * (default value) parent = designates a parent that can only be a sliding link texture_name = name of the texture that can be applied to the conveyor Object dispenser See 38 - demo_Convoyeurs.xrs Specialized synoptic object used to distribute a physical object in the scene at regular intervals. - At least one copy of the object to be distributed must be placed in the scene. - The number of objects distributed is limited to 16. dispenser library \\_Synoptic id_collision = * (default value) parent = designates a parent that can only be a sliding link texture_name = name of the texture that can be applied to the dispenser dropped_object = name of distributed physical object * sets the dispense point delay = dispensing interval in seconds [0.1 s to 30 s] show = True (False or True) show/hide object if dispenser is associated with a potentiometer button, the dispensing interval is adjustable between 0.1 s and delay . Synoptic assemblies Complete synoptics can be saved and retrieved using WinRelais' block commands. synoptic example imported tri_de_caisses :","title":"Synoptic"},{"location":"synoptic/#synoptic","text":"","title":"Synoptic"},{"location":"synoptic/#preamble","text":"The simulator allows you to create small operative parts that can be controlled with the actuators of the schematic. It integrates a 2D physics engine to bring a certain realism to the simulation. Example: This example shows two cylindrical drums on an inclined ramp, seen from the side. When the cylinder rod extends, the two drums are raised to the top of the ramp. When the cylinder rod retracts, the two drums roll (or slide, depending on the coefficient of friction applied) down the ramp, finally being locked in position by the cylinder nose. Two types of objects are used by the physical motor: - physical objects, which are subject to external forces and gravity. In particular, they have a mass in kilograms - kinematic objects, whose positions in the scene are controlled directly by the program. They are insensitive to external forces and therefore not subject to the laws of physics. Physical objects can collide with kinematic objects.","title":"Preamble"},{"location":"synoptic/#physical-object-settings","text":"|shape|library|Physics| | ---------------| ----------------------------------------------------------------------------------------| |dynamic =| True -> object is of type 'physical', False -> object is of type 'kinematic'| |masse =| mass in kg of the physical object [1 to 100 kg]| |friction =| coefficient of friction [0 to 100] applied to the physical object| |pas_de_rotation =| applies a considerable mass and inertia value to the physical object| |id_collision =| * (default value)| |texture_name =|image name ( png format only)| - if dynamics = False, parameters mass and friction are ignored.","title":"Physical object settings"},{"location":"synoptic/#kinematic-object-settings","text":"|kinematic|library|_Synoptic| | ---------------| ----------------------------------------------------------------------------------------| |parent =|designates a parent that can only be a sliding link| |id_collision =| * (default value)| |texture_name =|name of the image that can be applied to the object ( png format only)| |show =|True (False or True) show/hide object| - A kinematic object can be attached to a sliding link. - The show parameter allows the use of invisible 'walls'.","title":"Kinematic object settings"},{"location":"synoptic/#detector-and-limit-switch","text":"Detects physical and kinematic objects that enter the sensor/end-of-travel detection zone - A sensor is a specialized kinematic object available in the _Synoptique library. |sensor|library|_Synoptic| |-----------|--------------------------------------| |parent =| designates a parent that can only be a sliding link| |id_collision =| * (default value, detects all objects present in the detection zone)| |texture_name =|name of the image that can be applied to the object ( png format only)| | =|fixes the position of the indicator light (green square)| =|fixes the position of the indicator light (green square) A detector with id_collision = * detects all objects entering its detection zone. id_collision** is used to filter objects detected by a detector or limit switch component. For example : |Collision Object Filtering| | ----------------------------------------------| |sensor A detects only object P2| |sensor * detects objects P1, P2 and P3| |sensor B detects only object P3| - A sensor's detection zone is defined by a magenta (255,0,255) color contour. (255,0,255) . For example : If a texture name is defined, the application searches for the texture (in png format only) in the folder C:\\Users\\Public\\Documents\\Elec-CAO\\wrs-data\\textures If the texture name is not defined, or if the texture file is not found, a texture calculated by the program will be applied to the object using the outer edge coloured red . For example: The texture silhouette automatically defines the object's collision shape. - The physics engine uses the transparent part of the texture to delimit the collision shape in the form of a convex polygon, as shown below: Drawing constraint in WinSymbol .","title":"Detector and limit switch"},{"location":"synoptic/#slider-links","text":"Slider links are available in the _Synoptique library and are prefixed with the slider keyword: Description of slider parameters: |slider |library|_Synoptic| | ---------------| ----------------------------------------------------------------------------------------| |controle_direction =| designates the motor object used to control the mobile in direction| |speed_control =| designates the motor object used to control the mobile in speed| |speed =|speed in % of motor speed (transcribed as linear speed). [0 \u00e0100%]| |friction =|fixes the friction of the motor surface [0 to 100]| |id_collision =| * (default value, detects any object that collides)| |parent =| designates a parent which can only be another sliding link| |texture_name =| name of the texture that can be applied to the mobile. Elements of a sliding connection that can be edited in WinSymbol : These elements are differentiated in WinSymbol by specific colors: - (255,128,255) identifies the guideline and limits of movement (square and circle symbols), - (255,0,0) identifies the outer contour of the mobile. This contour must be a single convex polygon, - (255,0,255) identifies the optional collision shape, which must be a single convex polygon. If this polygon is not defined, the physics engine calculates the collision shape from the red outer contour. Examples","title":"Slider links"},{"location":"synoptic/#cylinder-actuator","text":"A cylinder is a specialized sliding link. VerinSE, VerinDE library _Verins pressure = nominal pressure [0 to 10 bar] speed = speed coefficient of rod movement [0 to 100%] id_collision = * (default value, detects any object colliding with it) texture_name = name of texture that can be applied to the rod","title":"Cylinder actuator"},{"location":"synoptic/#floating-cylinder-actuator","text":"Identical to the cylinder component, except that it can be attached to a sliding link. It is systematically associated with : a Label_Pression object for single-acting cylinders, two Label_Pression objects for double-acting cylinders. The names of Label_Pression objects are used in the float_inputs (or float_input ) parameter to connect cylinder ports. VerinDE_flottant library _Verins float_inputs = (Label_Pression orifice 1, Label_Pression orifice 2) parent = designates a parent which may be just another slide link pressure = nominal pressure [0 to 10 bar] speed = speed coefficient of rod movement [0 to 100%] id_collision = * (default value, detects any object colliding with it) texture_name = name of the texture that can be applied to the rod VerinSE_flottant library _Verins float_input = Label_Pression orifice 1 parent = designates a parent which may be just another slide link. pressure = nominal pressure [0 to 10 bar] speed = speed coefficient of rod displacement","title":"Floating cylinder actuator"},{"location":"synoptic/#sliding-link-and-kinship","text":"All kinematic objects can be attached to a sliding link. This is extremely useful for creating non-convex collision shapes, for example : The rod nose is a kinematic object attached to the cylinder rod through the parent parameter : Several kinematic objects can be attached:","title":"Sliding link and kinship"},{"location":"synoptic/#top-view-conveyor","text":"Top-view conveyors are available in the _Synoptique library and are prefixed with the conveyor keyword: conveyor library \\_Synoptic controle_direction = motor object used to control conveyor diection control_speed = motor object used to control speed speed = conveyor speed as % of motor speed (transcribed as linear speed). [0 \u00e0 100%] friction = fixes conveyor friction [0 to 100] id_collision = * (default value) parent = designates a parent that can only be a sliding link texture_name = name of the texture that can be applied to the conveyor","title":"Top view conveyor"},{"location":"synoptic/#side-view-conveyor","text":"Side-view conveyors are available in the _Synoptique library and are prefixed with the side_conveyor keyword: side_conveyor library \\_Synoptic control_direction = motor object used to control conveyor diection speed_control = motor object used to control speed speed = conveyor speed as % of motor speed (transcribed as linear speed). [0 \u00e0 100%] friction = fixes conveyor friction [0 to 100] id_collision = * (default value) parent = designates a parent that can only be a sliding link texture_name = name of the texture that can be applied to the conveyor","title":"Side view conveyor"},{"location":"synoptic/#object-dispenser","text":"See 38 - demo_Convoyeurs.xrs Specialized synoptic object used to distribute a physical object in the scene at regular intervals. - At least one copy of the object to be distributed must be placed in the scene. - The number of objects distributed is limited to 16. dispenser library \\_Synoptic id_collision = * (default value) parent = designates a parent that can only be a sliding link texture_name = name of the texture that can be applied to the dispenser dropped_object = name of distributed physical object * sets the dispense point delay = dispensing interval in seconds [0.1 s to 30 s] show = True (False or True) show/hide object if dispenser is associated with a potentiometer button, the dispensing interval is adjustable between 0.1 s and delay .","title":"Object dispenser"},{"location":"synoptic/#synoptic-assemblies","text":"Complete synoptics can be saved and retrieved using WinRelais' block commands. synoptic example imported tri_de_caisses :","title":"Synoptic assemblies"},{"location":"fr/","text":"Accueil R\u00e9vision 2 septembre 2024 Logiciel WRSimulateur Version 1.5 port\u00e9e par WinRelais Studio 2.5.0 (2.5c) Auteur Fr\u00e9d\u00e9ric POPEK Editeur INGEREA Objectifs du simulateur L'objectif du simulateur est de permettre aux utilisateurs de simuler des circuits \u00e9lectriques, \u00e9lectrotechniques et pneumatiques pour un usage p\u00e9dagogique et de pr\u00e9sentation en avant-projet. Le simulateur permet notamment la simulation d'installations de type SAP (Syst\u00e8me Automatis\u00e9 de Production) en utilisant un automate programmable virtuel ou physique connect\u00e9 en MODBUS/TCP-IP, coupl\u00e9 \u00e0 une partie op\u00e9rative anim\u00e9e. Le simulateur int\u00e8gre un mod\u00e8le de simulation mixte analogique/num\u00e9rique qui permet la simulation simultan\u00e9e - de circuits \u00e9lectriques/\u00e9lectrotechniques standards, - de circuits pneumatiques, - d'objets complexes (variateurs de vitesse, relais de s\u00e9curit\u00e9, etc.) - d'automates programmables, - de parties op\u00e9ratives simples Premiers pas Ouvrir un exemple Deux possibilt\u00e9s: Ouvrir un exemple \u00e0 partir de WinRelais Fichier>Ouvrir wr-schema/Demonstration Simulateur WinRelais Studio/ : Un acc\u00e8s rapide au dossier Demonstration Simulateur WinRelais Studio est construit \u00e0 l'installation. Il est ainsi possibble de lancer directement WinRelais avec l'exemple s\u00e9lectionn\u00e9 : Lancer le simulateur En cliquant sur l'ic\u00f4ne: Contr\u00f4les r\u00e9alis\u00e9s par le simulateur Les contr\u00f4les r\u00e9alis\u00e9s par le simulateur donnent trois niveaux d'avertissement : Liste des avertissements","title":"Accueil"},{"location":"fr/#accueil","text":"R\u00e9vision 2 septembre 2024 Logiciel WRSimulateur Version 1.5 port\u00e9e par WinRelais Studio 2.5.0 (2.5c) Auteur Fr\u00e9d\u00e9ric POPEK Editeur INGEREA","title":"Accueil"},{"location":"fr/#objectifs-du-simulateur","text":"L'objectif du simulateur est de permettre aux utilisateurs de simuler des circuits \u00e9lectriques, \u00e9lectrotechniques et pneumatiques pour un usage p\u00e9dagogique et de pr\u00e9sentation en avant-projet. Le simulateur permet notamment la simulation d'installations de type SAP (Syst\u00e8me Automatis\u00e9 de Production) en utilisant un automate programmable virtuel ou physique connect\u00e9 en MODBUS/TCP-IP, coupl\u00e9 \u00e0 une partie op\u00e9rative anim\u00e9e. Le simulateur int\u00e8gre un mod\u00e8le de simulation mixte analogique/num\u00e9rique qui permet la simulation simultan\u00e9e - de circuits \u00e9lectriques/\u00e9lectrotechniques standards, - de circuits pneumatiques, - d'objets complexes (variateurs de vitesse, relais de s\u00e9curit\u00e9, etc.) - d'automates programmables, - de parties op\u00e9ratives simples","title":"Objectifs du simulateur"},{"location":"fr/#premiers-pas","text":"","title":"Premiers pas"},{"location":"fr/#ouvrir-un-exemple","text":"Deux possibilt\u00e9s: Ouvrir un exemple \u00e0 partir de WinRelais Fichier>Ouvrir wr-schema/Demonstration Simulateur WinRelais Studio/ : Un acc\u00e8s rapide au dossier Demonstration Simulateur WinRelais Studio est construit \u00e0 l'installation. Il est ainsi possibble de lancer directement WinRelais avec l'exemple s\u00e9lectionn\u00e9 :","title":"Ouvrir un exemple"},{"location":"fr/#lancer-le-simulateur","text":"En cliquant sur l'ic\u00f4ne:","title":"Lancer le simulateur"},{"location":"fr/#controles-realises-par-le-simulateur","text":"Les contr\u00f4les r\u00e9alis\u00e9s par le simulateur donnent trois niveaux d'avertissement : Liste des avertissements","title":"Contr\u00f4les r\u00e9alis\u00e9s par le simulateur"},{"location":"fr/errors/","text":"Liste Avertissements Au lancement du simulateur, des v\u00e9rifications sont faites sur le sch\u00e9ma \u00e0 simuler. Avertissement bloquant : le simulateur arr\u00eate la v\u00e9rification \u00e0 la premi\u00e8re erreur rencontr\u00e9e et emp\u00eache la simulation tant que l'erreur n'est pas r\u00e9solue. Avertissements non bloquants : le simulateur remplace la valeur des param\u00e8tre non trouv\u00e9s ou illisibles par des valeurs par d\u00e9faut et autorise quand m\u00eame la simulation. Avertissements bloquants BLOQUANTS {nb_doublons} objets nomm\u00e9s {name} sont pr\u00e9sents dans le sch\u00e9ma, un seul est autoris\u00e9 il manque le composant {master} pour contr\u00f4ler le {slave} l'objet {slave} est incompatible avec l'objet {master} L'objet {name} qui contr\u00f4le la direction n'est pas un moteur L'objet {name} qui pilote la direction n'existe pas adresse API erronn\u00e9e : Format attendu : %{I,Q}m.c avec m[0,5] et c[0,31], exemple : %I1.12 adresse API erronn\u00e9e : Format attendu : %{IW, QW}m.c avec m[0,5] et c[0,3], exemple : %IW1.1 Le parent de l'objet API n'existe pas rep\u00e8re d'E/S illisible : il doit commencer par % Le parent {name} n'existe pas la broche {broche} de l'objet {name} n'est pas raccord\u00e9e 'dropped_object' {name} n'existe pas 'dropped_object' {name} n'est pas un objet de la famille '_physique' L'objet {label_pression} n'est pas un label_pression L'objet {label_pression} n'existe pas la clef 'controle1' de {name'} est non d\u00e9finie la clef 'controle2' de {name'} est non d\u00e9finie objet de contr\u00f4le {ctrl} manquant pour {slave} les deux objets nomm\u00e9s {name} doivent \u00eatre du type SET et RESET le nombre d'objets {name} doit \u00eatre strictement \u00e8gal \u00e0 2 (SET et RESET) deux objets nomm\u00e9s {name} ont des familles incompatibles : {slave} et {master} l'objet IHM {name} est incompatible avec l'objet {name} l'identificateur de collision du capteur {name} ne trouve pas de correspondance liaison fausse trouv\u00e9e : folio arriv\u00e9e/d\u00e9part non valide renvoi {renvoi} dans le folio {folio} non connect\u00e9 l'objet {name} {folio} n'est pas simulable Le sch\u00e9ma \u00e0 simuler est trop grand probl\u00e8me grave pour le composant : bug logiciel. Merci de contacter le support Avertissements non bloquants {HORS_INTERVALLE} 'alpha' {HORS_INTERVALLE} (0 <= alpha <= 100), valeur r\u00e9gl\u00e9e \u00e0 50%\" 'accrochage' {HORS_INTERVALLE} [vrai,faux], valeur r\u00e9gl\u00e9e \u00e0 faux 'etat_init' {HORS_INTERVALLE} [vrai,faux], valeur r\u00e9gl\u00e9e \u00e0 faux 'delai' {HORS_INTERVALLE} (0.1 <= delai <= 30), valeur r\u00e9gl\u00e9e \u00e0 1s masse' {HORS_INTERVALLE} (0.1 <= masse <= 100 kg) 'friction' {HORS_INTERVALLE} (0 <= friction <= 100) 'port' {HORS_INTERVALLE} (500 <= port <= 1000), valeur r\u00e9gl\u00e9e \u00e0 502 'adresse_table_echange' (0 <= adress <= 1990), valeur r\u00e9gl\u00e9e 400 'ID_unite' {HORS_INTERVALLE} (0 <= ID_unite <= 247), valeur r\u00e9gl\u00e9e 111 'gravity' {HORS_INTERVALLE} (0 <= gravity <= 10), valeur r\u00e9gl\u00e9e 0 'amortisement' {HORS_INTERVALLE} (0 <= damping <= 10), valeur r\u00e9gl\u00e9e \u00e0 0 'damping' {HORS_INTERVALLE} (0 <= damping <= 10), {VALUE_SET_TO} 0 'valeur' {HORS_INTERVALLE} (1pF <= valeur <= 10000uF), valeur r\u00e9gl\u00e9e \u00e0 100uF 'valeur' {HORS_INTERVALLE} (1e-3 <= valeur <= 10e6), valeur r\u00e9gl\u00e9e \u00e0 100 ohms 'valeur' {HORS_INTERVALLE} (1e-3 <= valeur <= 10e6), valeur r\u00e9gl\u00e9e \u00e0 100 ohms 'alpha' {HORS_INTERVALLE} (0 <= alpha <= 100), valeur r\u00e9gl\u00e9e \u00e0 50% 'pn' {HORS_INTERVALLE} (10 W <= Pn <= 22 kW), valeur r\u00e9gl\u00e9e \u00e0 {values['pn']/1000} kW 'vn' {HORS_INTERVALLE} (12 <= vn <= 400 V), valeur r\u00e9gl\u00e9e \u00e0 {values['vn']} V 'vfrein' {HORS_INTERVALLE} (12 <= v <= 400), valeur r\u00e9gl\u00e9e \u00e0 {values['vn']} V 'nm' {HORS_INTERVALLE} (700 <= nm <= 3000), valeur r\u00e9gl\u00e9e \u00e0 {values['nm']} rpm 'nm1' {HORS_INTERVALLE} (700 <= nm1 <= 3000), valeur r\u00e9gl\u00e9e \u00e0 {values['nm1']} rpm 'nm2' {HORS_INTERVALLE} (700 <= nm2 <= 3000), valeur r\u00e9gl\u00e9e \u00e0 {values['nm2']} rpm 'cos' {HORS_INTERVALLE} (0.5 <= cos(phi) <= 1), valeur r\u00e9gl\u00e9e \u00e0 {values['cos']} 'rendement' {HORS_INTERVALLE} (0.35 <= rendement <= 1), valeur r\u00e9gl\u00e9e \u00e0 {values['rendement']} 'venroulement' {HORS_INTERVALLE} (24V <= venroulement <= 400V), valeur r\u00e9gl\u00e9e \u00e0 230 V 'venroulement1' {HORS_INTERVALLE} (24V <= vcoil1 <= 400V), valeur r\u00e9gl\u00e9e \u00e0 230 V 'venroulement2' {HORS_INTERVALLE} (24V <= venroulement2 <= 400V), valeur r\u00e9gl\u00e9e \u00e0 230 V 'vinduit' {HORS_INTERVALLE} (12V <= vinduit <= 320V), valeur r\u00e9gl\u00e9e \u00e0 100 V 'couplage' {HORS_INTERVALLE} (\u00e9toile ou triangle), couplage choisi : \u00e9toile 'couplage1' {HORS_INTERVALLE} (\u00e9toile ou triangle), couplage choisi : \u00e9toile 'couplage2' {HORS_INTERVALLE} (\u00e9toile ou triangle), couplage choisi : \u00e9toile 'Idn' {HORS_INTERVALLE} (10 mA <= Idn <= 10000 mA), valeur r\u00e9gl\u00e9e \u00e0 100 mA 'retard_diff' {HORS_INTERVALLE} (0 ms<= retard_diff <= 10000 ms), valeur r\u00e9gl\u00e9e \u00e0 0 ms 'retard_rth' {HORS_INTERVALLE} (1s<= retard_rth <= 30s ), valeur r\u00e9gl\u00e9e \u00e0 10 s 'retard' {HORS_INTERVALLE} (0 ms<= retard <= 10000 ms), valeur r\u00e9gl\u00e9e \u00e0 0 ms 'Ith' {HORS_INTERVALLE} (0.1 A<= Ith <= 100 A), valeur r\u00e9gl\u00e9e \u00e0 10 A 'In' {HORS_INTERVALLE} (0.5 A<= In <= 100 A), valeur r\u00e9gl\u00e9e \u00e0 10 A 'courbe' {HORS_INTERVALLE} (B, C ou D), valeur r\u00e9gl\u00e9e \u00e0 C 'typeF' {HORS_INTERVALLE} (gG ou aM), type choisi : aM 'Pn' {HORS_INTERVALLE} (0.5 VA <= Pn <= 200 VA), valeur r\u00e9gl\u00e9e \u00e0 {values['pn']} W 'vn' {HORS_INTERVALLE} (12 <= vn <= 400), valeur r\u00e9gl\u00e9e \u00e0 {values['vn']} V 'Pn' {HORS_INTERVALLE} (0.5 W <= Pn <= 2 kW), valeur r\u00e9gl\u00e9e \u00e0 {values['pn']} W 'couleur' {HORS_INTERVALLE} (rouge, vert, bleu, orange, blanc), valeur r\u00e9gl\u00e9e \u00e0 'rouge' 'ton' {HORS_INTERVALLE} (0.5s <= ton <= 30s), valeur r\u00e9gl\u00e9e \u00e0 1s 'toff' {HORS_INTERVALLE} (0.5s <= toff <= 30s), valeur r\u00e9gl\u00e9e \u00e0 1s 'output_range' {HORS_INTERVALLE} valeur min = (0, 4) et valeur maxi = 20, valeur r\u00e9gl\u00e9e \u00e0 (4,20) mA 'output_range' {HORS_INTERVALLE} valeur min = -30 et valeur maxi = 30, valeur r\u00e9gl\u00e9e \u00e0 (0,10) V 'output_scale' {HORS_INTERVALLE} valeur min = -32768 et valeur maxi = 32767, valeur r\u00e9gl\u00e9e \u00e0 (0,1000) 'input_scale' {HORS_INTERVALLE} valeur min = -32768 et valeur maxi = 32767, valeur r\u00e9gl\u00e9e \u00e0 (0,1000) 'voltage_range' {HORS_INTERVALLE} valeur min = -1000 et valeur maxi = 1000, valeur r\u00e9gl\u00e9e \u00e0 (0,10) V 'current_range' {HORS_INTERVALLE} (min,max) = (-1, 1) A, valeur r\u00e9gl\u00e9e \u00e0 (4,20) mA 'pression' {HORS_INTERVALLE} (0 <= pression <= 10.0 bar), valeur r\u00e9gl\u00e9e \u00e0 6 bar 've' {HORS_INTERVALLE} (5 <= ve <= 400), valeur r\u00e9gl\u00e9e \u00e0 {values['vin']} V 'vs' {HORS_INTERVALLE} (5 <= vs <= 400), valeur r\u00e9gl\u00e9e \u00e0 {values['vout']} V 'vs1' {HORS_INTERVALLE} (5 <= vs1 <= 400), valeur r\u00e9gl\u00e9e \u00e0 {values['vout1']} V 'vs2' {HORS_INTERVALLE} (5 <= vs2 <= 400), valeur r\u00e9gl\u00e9e \u00e0 {values['vout2']} V 'vbat' {HORS_INTERVALLE} (0 <= vbat <= 400), valeur r\u00e9gl\u00e9e \u00e0 {values['vbat']} V {power} {HORS_INTERVALLE} (90 W <= {power} <= 22 kW), valeur r\u00e9gl\u00e9e \u00e0 {values[{power}]/1000} kW ILLISIBLE 'masse' {ILLISIBLE} valeur r\u00e9gl\u00e9e \u00e0 1 kg 'friction' {ILLISIBLE} valeur r\u00e9gl\u00e9e \u00e0 1 'adresse_ip' {ILLISIBLE} valeur r\u00e9gl\u00e9e \u00e0 127.0.0.1 'port' {ILLISIBLE} valeur r\u00e9gl\u00e9e \u00e0 502 'adresse_table_echange' {ILLISIBLE} valeur r\u00e9gl\u00e9e \u00e0 400 'ID_unite' {ILLISIBLE} valeur r\u00e9gl\u00e9e \u00e0 111 'gravity' {ILLISIBLE} valeur r\u00e9gl\u00e9e \u00e0 0 'amortisement' {ILLISIBLE} valeur r\u00e9gl\u00e9e \u00e0 0 'damping' {ILLISIBLE} {VALUE_SET_TO} 0 'valeur' {ILLISIBLE} valeur r\u00e9gl\u00e9e \u00e0 100 uF 'valeur' {ILLISIBLE} valeur r\u00e9gl\u00e9e \u00e0 100 ohms 'valeur' {ILLISIBLE} valeur r\u00e9gl\u00e9e \u00e0 100 ohms 'alpha' {ILLISIBLE} valeur r\u00e9gl\u00e9e \u00e0 50% 'Pn' {ILLISIBLE} valeur r\u00e9gl\u00e9e \u00e0 {values['pn']/1000} kW 'vn' {ILLISIBLE} valeur r\u00e9gl\u00e9e \u00e0 {values['vn']} V 'v' {ILLISIBLE} valeur r\u00e9gl\u00e9e \u00e0 {values['vn']} V 'nm' {ILLISIBLE} valeur r\u00e9gl\u00e9e \u00e0 {values['nm']} rpm 'nm1' {ILLISIBLE} valeur r\u00e9gl\u00e9e \u00e0 {values['nm1']} rpm 'nm2' {ILLISIBLE} valeur r\u00e9gl\u00e9e \u00e0 {values['nm2']} rpm 'cos' {ILLISIBLE} valeur r\u00e9gl\u00e9e \u00e0 {values['cos']} 'rendement' {ILLISIBLE} valeur r\u00e9gl\u00e9e \u00e0 {values['rendement']} 'venroulement' {ILLISIBLE} valeur r\u00e9gl\u00e9e \u00e0 {values['venroulement']/0.98:2.0f} V 'venroulement1' {ILLISIBLE} valeur r\u00e9gl\u00e9e \u00e0 {values['venroulement1']/0.98:2.0f} V 'venroulement2' {ILLISIBLE} valeur r\u00e9gl\u00e9e \u00e0 {values['venroulement2']/0.98:2.0f} V 'vinduit' {ILLISIBLE} valeur r\u00e9gl\u00e9e \u00e0 {values['va']/0.98:2.0f} V 'Idn' {ILLISIBLE} valeur r\u00e9gl\u00e9e \u00e0 {values['idn']} mA 'retard_diff' {ILLISIBLE} {VALUE_SET_TO} {values['retard_diff']} ms 'retard_rth' {ILLISIBLE} valeur r\u00e9gl\u00e9e \u00e0 {values['retard_rth']} s 'retard' {ILLISIBLE} valeur r\u00e9gl\u00e9e \u00e0 {values['retard']} ms 'Ith' {ILLISIBLE} {VALUE_SET_TO} {values['ith']} A 'In' {ILLISIBLE} valeur r\u00e9gl\u00e9e \u00e0 {values['in']} A 'Pn' {ILLISIBLE} valeur r\u00e9gl\u00e9e \u00e0 {values['pn']} W 'vn' {ILLISIBLE} valeur r\u00e9gl\u00e9e \u00e0 {values['vn']} V 'couleur' {ILLISIBLE} valeur r\u00e9gl\u00e9e \u00e0 'rouge' 'vn' {ILLISIBLE} valeur r\u00e9gl\u00e9e \u00e0 24 V 'ton' {ILLISIBLE} valeur r\u00e9gl\u00e9e \u00e0 1s 'toff' {ILLISIBLE} valeur r\u00e9gl\u00e9e \u00e0 1s 'output_type' {ILLISIBLE} (output_type = V ou I), 'output_type' r\u00e9gl\u00e9 sur 'V' 'output_type' {ILLISIBLE} (output_type = V ou I), 'output_type' r\u00e9gl\u00e9 sur 'V' 'output_range' {ILLISIBLE} valeur r\u00e9gl\u00e9e \u00e0 (4,20) mA 'output_range' {ILLISIBLE} valeur r\u00e9gl\u00e9e \u00e0 (0,10) V 'output_scale' {ILLISIBLE} valeur r\u00e9gl\u00e9e \u00e0 (0,1000) 'input_type' {ILLISIBLE} (input_type = V ou I), 'input_type' r\u00e9gl\u00e9 sur 'V' 'input_type' {ILLISIBLE} (input_type = V ou I), 'input_type' r\u00e9gl\u00e9 sur 'V' 'input_range' {ILLISIBLE} valeur r\u00e9gl\u00e9e \u00e0 (4,20) mA 'input_range' {ILLISIBLE} valeur r\u00e9gl\u00e9e \u00e0 (0,10) V 'input_scale' {ILLISIBLE} valeur r\u00e9gl\u00e9e \u00e0 (0,1000) 'v' {ILLISIBLE} valeur r\u00e9gl\u00e9e \u00e0 {values['vn']} V 'voltage_range' {ILLISIBLE} valeur r\u00e9gl\u00e9e \u00e0 (0,10) V 'current_range' {ILLISIBLE} valeur r\u00e9gl\u00e9e \u00e0 (4,20) mA 'pression' {ILLISIBLE} valeur r\u00e9gl\u00e9e \u00e0 {values['pression']} bar 've' {ILLISIBLE} valeur r\u00e9gl\u00e9e \u00e0 {values['vin']} V 'vs' {ILLISIBLE} valeur r\u00e9gl\u00e9e \u00e0 {values['vout']} V 'vs1' {ILLISIBLE} valeur r\u00e9gl\u00e9e \u00e0 {values['vout1']} V 'vs2' {ILLISIBLE} valeur r\u00e9gl\u00e9e \u00e0 {values['vout2']} V 'vbat' {ILLISIBLE} valeur r\u00e9gl\u00e9e \u00e0 {values['vbat']} V 'format' {ILLISIBLE} (format = ac ou dc), 'format' r\u00e9gl\u00e9 sur 'dc' {power} {ILLISIBLE} valeur r\u00e9gl\u00e9e \u00e0 {values[{power}]/1000} kW param\u00e8tre {k} {ILLISIBLE} valeur d'usine {values[k]} {limits[k][0]} choisie","title":"Liste avertissements"},{"location":"fr/errors/#liste-avertissements","text":"Au lancement du simulateur, des v\u00e9rifications sont faites sur le sch\u00e9ma \u00e0 simuler. Avertissement bloquant : le simulateur arr\u00eate la v\u00e9rification \u00e0 la premi\u00e8re erreur rencontr\u00e9e et emp\u00eache la simulation tant que l'erreur n'est pas r\u00e9solue. Avertissements non bloquants : le simulateur remplace la valeur des param\u00e8tre non trouv\u00e9s ou illisibles par des valeurs par d\u00e9faut et autorise quand m\u00eame la simulation.","title":"Liste Avertissements"},{"location":"fr/errors/#avertissements-bloquants","text":"BLOQUANTS {nb_doublons} objets nomm\u00e9s {name} sont pr\u00e9sents dans le sch\u00e9ma, un seul est autoris\u00e9 il manque le composant {master} pour contr\u00f4ler le {slave} l'objet {slave} est incompatible avec l'objet {master} L'objet {name} qui contr\u00f4le la direction n'est pas un moteur L'objet {name} qui pilote la direction n'existe pas adresse API erronn\u00e9e : Format attendu : %{I,Q}m.c avec m[0,5] et c[0,31], exemple : %I1.12 adresse API erronn\u00e9e : Format attendu : %{IW, QW}m.c avec m[0,5] et c[0,3], exemple : %IW1.1 Le parent de l'objet API n'existe pas rep\u00e8re d'E/S illisible : il doit commencer par % Le parent {name} n'existe pas la broche {broche} de l'objet {name} n'est pas raccord\u00e9e 'dropped_object' {name} n'existe pas 'dropped_object' {name} n'est pas un objet de la famille '_physique' L'objet {label_pression} n'est pas un label_pression L'objet {label_pression} n'existe pas la clef 'controle1' de {name'} est non d\u00e9finie la clef 'controle2' de {name'} est non d\u00e9finie objet de contr\u00f4le {ctrl} manquant pour {slave} les deux objets nomm\u00e9s {name} doivent \u00eatre du type SET et RESET le nombre d'objets {name} doit \u00eatre strictement \u00e8gal \u00e0 2 (SET et RESET) deux objets nomm\u00e9s {name} ont des familles incompatibles : {slave} et {master} l'objet IHM {name} est incompatible avec l'objet {name} l'identificateur de collision du capteur {name} ne trouve pas de correspondance liaison fausse trouv\u00e9e : folio arriv\u00e9e/d\u00e9part non valide renvoi {renvoi} dans le folio {folio} non connect\u00e9 l'objet {name} {folio} n'est pas simulable Le sch\u00e9ma \u00e0 simuler est trop grand probl\u00e8me grave pour le composant : bug logiciel. Merci de contacter le support","title":"Avertissements bloquants"},{"location":"fr/errors/#avertissements-non-bloquants","text":"{HORS_INTERVALLE} 'alpha' {HORS_INTERVALLE} (0 <= alpha <= 100), valeur r\u00e9gl\u00e9e \u00e0 50%\" 'accrochage' {HORS_INTERVALLE} [vrai,faux], valeur r\u00e9gl\u00e9e \u00e0 faux 'etat_init' {HORS_INTERVALLE} [vrai,faux], valeur r\u00e9gl\u00e9e \u00e0 faux 'delai' {HORS_INTERVALLE} (0.1 <= delai <= 30), valeur r\u00e9gl\u00e9e \u00e0 1s masse' {HORS_INTERVALLE} (0.1 <= masse <= 100 kg) 'friction' {HORS_INTERVALLE} (0 <= friction <= 100) 'port' {HORS_INTERVALLE} (500 <= port <= 1000), valeur r\u00e9gl\u00e9e \u00e0 502 'adresse_table_echange' (0 <= adress <= 1990), valeur r\u00e9gl\u00e9e 400 'ID_unite' {HORS_INTERVALLE} (0 <= ID_unite <= 247), valeur r\u00e9gl\u00e9e 111 'gravity' {HORS_INTERVALLE} (0 <= gravity <= 10), valeur r\u00e9gl\u00e9e 0 'amortisement' {HORS_INTERVALLE} (0 <= damping <= 10), valeur r\u00e9gl\u00e9e \u00e0 0 'damping' {HORS_INTERVALLE} (0 <= damping <= 10), {VALUE_SET_TO} 0 'valeur' {HORS_INTERVALLE} (1pF <= valeur <= 10000uF), valeur r\u00e9gl\u00e9e \u00e0 100uF 'valeur' {HORS_INTERVALLE} (1e-3 <= valeur <= 10e6), valeur r\u00e9gl\u00e9e \u00e0 100 ohms 'valeur' {HORS_INTERVALLE} (1e-3 <= valeur <= 10e6), valeur r\u00e9gl\u00e9e \u00e0 100 ohms 'alpha' {HORS_INTERVALLE} (0 <= alpha <= 100), valeur r\u00e9gl\u00e9e \u00e0 50% 'pn' {HORS_INTERVALLE} (10 W <= Pn <= 22 kW), valeur r\u00e9gl\u00e9e \u00e0 {values['pn']/1000} kW 'vn' {HORS_INTERVALLE} (12 <= vn <= 400 V), valeur r\u00e9gl\u00e9e \u00e0 {values['vn']} V 'vfrein' {HORS_INTERVALLE} (12 <= v <= 400), valeur r\u00e9gl\u00e9e \u00e0 {values['vn']} V 'nm' {HORS_INTERVALLE} (700 <= nm <= 3000), valeur r\u00e9gl\u00e9e \u00e0 {values['nm']} rpm 'nm1' {HORS_INTERVALLE} (700 <= nm1 <= 3000), valeur r\u00e9gl\u00e9e \u00e0 {values['nm1']} rpm 'nm2' {HORS_INTERVALLE} (700 <= nm2 <= 3000), valeur r\u00e9gl\u00e9e \u00e0 {values['nm2']} rpm 'cos' {HORS_INTERVALLE} (0.5 <= cos(phi) <= 1), valeur r\u00e9gl\u00e9e \u00e0 {values['cos']} 'rendement' {HORS_INTERVALLE} (0.35 <= rendement <= 1), valeur r\u00e9gl\u00e9e \u00e0 {values['rendement']} 'venroulement' {HORS_INTERVALLE} (24V <= venroulement <= 400V), valeur r\u00e9gl\u00e9e \u00e0 230 V 'venroulement1' {HORS_INTERVALLE} (24V <= vcoil1 <= 400V), valeur r\u00e9gl\u00e9e \u00e0 230 V 'venroulement2' {HORS_INTERVALLE} (24V <= venroulement2 <= 400V), valeur r\u00e9gl\u00e9e \u00e0 230 V 'vinduit' {HORS_INTERVALLE} (12V <= vinduit <= 320V), valeur r\u00e9gl\u00e9e \u00e0 100 V 'couplage' {HORS_INTERVALLE} (\u00e9toile ou triangle), couplage choisi : \u00e9toile 'couplage1' {HORS_INTERVALLE} (\u00e9toile ou triangle), couplage choisi : \u00e9toile 'couplage2' {HORS_INTERVALLE} (\u00e9toile ou triangle), couplage choisi : \u00e9toile 'Idn' {HORS_INTERVALLE} (10 mA <= Idn <= 10000 mA), valeur r\u00e9gl\u00e9e \u00e0 100 mA 'retard_diff' {HORS_INTERVALLE} (0 ms<= retard_diff <= 10000 ms), valeur r\u00e9gl\u00e9e \u00e0 0 ms 'retard_rth' {HORS_INTERVALLE} (1s<= retard_rth <= 30s ), valeur r\u00e9gl\u00e9e \u00e0 10 s 'retard' {HORS_INTERVALLE} (0 ms<= retard <= 10000 ms), valeur r\u00e9gl\u00e9e \u00e0 0 ms 'Ith' {HORS_INTERVALLE} (0.1 A<= Ith <= 100 A), valeur r\u00e9gl\u00e9e \u00e0 10 A 'In' {HORS_INTERVALLE} (0.5 A<= In <= 100 A), valeur r\u00e9gl\u00e9e \u00e0 10 A 'courbe' {HORS_INTERVALLE} (B, C ou D), valeur r\u00e9gl\u00e9e \u00e0 C 'typeF' {HORS_INTERVALLE} (gG ou aM), type choisi : aM 'Pn' {HORS_INTERVALLE} (0.5 VA <= Pn <= 200 VA), valeur r\u00e9gl\u00e9e \u00e0 {values['pn']} W 'vn' {HORS_INTERVALLE} (12 <= vn <= 400), valeur r\u00e9gl\u00e9e \u00e0 {values['vn']} V 'Pn' {HORS_INTERVALLE} (0.5 W <= Pn <= 2 kW), valeur r\u00e9gl\u00e9e \u00e0 {values['pn']} W 'couleur' {HORS_INTERVALLE} (rouge, vert, bleu, orange, blanc), valeur r\u00e9gl\u00e9e \u00e0 'rouge' 'ton' {HORS_INTERVALLE} (0.5s <= ton <= 30s), valeur r\u00e9gl\u00e9e \u00e0 1s 'toff' {HORS_INTERVALLE} (0.5s <= toff <= 30s), valeur r\u00e9gl\u00e9e \u00e0 1s 'output_range' {HORS_INTERVALLE} valeur min = (0, 4) et valeur maxi = 20, valeur r\u00e9gl\u00e9e \u00e0 (4,20) mA 'output_range' {HORS_INTERVALLE} valeur min = -30 et valeur maxi = 30, valeur r\u00e9gl\u00e9e \u00e0 (0,10) V 'output_scale' {HORS_INTERVALLE} valeur min = -32768 et valeur maxi = 32767, valeur r\u00e9gl\u00e9e \u00e0 (0,1000) 'input_scale' {HORS_INTERVALLE} valeur min = -32768 et valeur maxi = 32767, valeur r\u00e9gl\u00e9e \u00e0 (0,1000) 'voltage_range' {HORS_INTERVALLE} valeur min = -1000 et valeur maxi = 1000, valeur r\u00e9gl\u00e9e \u00e0 (0,10) V 'current_range' {HORS_INTERVALLE} (min,max) = (-1, 1) A, valeur r\u00e9gl\u00e9e \u00e0 (4,20) mA 'pression' {HORS_INTERVALLE} (0 <= pression <= 10.0 bar), valeur r\u00e9gl\u00e9e \u00e0 6 bar 've' {HORS_INTERVALLE} (5 <= ve <= 400), valeur r\u00e9gl\u00e9e \u00e0 {values['vin']} V 'vs' {HORS_INTERVALLE} (5 <= vs <= 400), valeur r\u00e9gl\u00e9e \u00e0 {values['vout']} V 'vs1' {HORS_INTERVALLE} (5 <= vs1 <= 400), valeur r\u00e9gl\u00e9e \u00e0 {values['vout1']} V 'vs2' {HORS_INTERVALLE} (5 <= vs2 <= 400), valeur r\u00e9gl\u00e9e \u00e0 {values['vout2']} V 'vbat' {HORS_INTERVALLE} (0 <= vbat <= 400), valeur r\u00e9gl\u00e9e \u00e0 {values['vbat']} V {power} {HORS_INTERVALLE} (90 W <= {power} <= 22 kW), valeur r\u00e9gl\u00e9e \u00e0 {values[{power}]/1000} kW ILLISIBLE 'masse' {ILLISIBLE} valeur r\u00e9gl\u00e9e \u00e0 1 kg 'friction' {ILLISIBLE} valeur r\u00e9gl\u00e9e \u00e0 1 'adresse_ip' {ILLISIBLE} valeur r\u00e9gl\u00e9e \u00e0 127.0.0.1 'port' {ILLISIBLE} valeur r\u00e9gl\u00e9e \u00e0 502 'adresse_table_echange' {ILLISIBLE} valeur r\u00e9gl\u00e9e \u00e0 400 'ID_unite' {ILLISIBLE} valeur r\u00e9gl\u00e9e \u00e0 111 'gravity' {ILLISIBLE} valeur r\u00e9gl\u00e9e \u00e0 0 'amortisement' {ILLISIBLE} valeur r\u00e9gl\u00e9e \u00e0 0 'damping' {ILLISIBLE} {VALUE_SET_TO} 0 'valeur' {ILLISIBLE} valeur r\u00e9gl\u00e9e \u00e0 100 uF 'valeur' {ILLISIBLE} valeur r\u00e9gl\u00e9e \u00e0 100 ohms 'valeur' {ILLISIBLE} valeur r\u00e9gl\u00e9e \u00e0 100 ohms 'alpha' {ILLISIBLE} valeur r\u00e9gl\u00e9e \u00e0 50% 'Pn' {ILLISIBLE} valeur r\u00e9gl\u00e9e \u00e0 {values['pn']/1000} kW 'vn' {ILLISIBLE} valeur r\u00e9gl\u00e9e \u00e0 {values['vn']} V 'v' {ILLISIBLE} valeur r\u00e9gl\u00e9e \u00e0 {values['vn']} V 'nm' {ILLISIBLE} valeur r\u00e9gl\u00e9e \u00e0 {values['nm']} rpm 'nm1' {ILLISIBLE} valeur r\u00e9gl\u00e9e \u00e0 {values['nm1']} rpm 'nm2' {ILLISIBLE} valeur r\u00e9gl\u00e9e \u00e0 {values['nm2']} rpm 'cos' {ILLISIBLE} valeur r\u00e9gl\u00e9e \u00e0 {values['cos']} 'rendement' {ILLISIBLE} valeur r\u00e9gl\u00e9e \u00e0 {values['rendement']} 'venroulement' {ILLISIBLE} valeur r\u00e9gl\u00e9e \u00e0 {values['venroulement']/0.98:2.0f} V 'venroulement1' {ILLISIBLE} valeur r\u00e9gl\u00e9e \u00e0 {values['venroulement1']/0.98:2.0f} V 'venroulement2' {ILLISIBLE} valeur r\u00e9gl\u00e9e \u00e0 {values['venroulement2']/0.98:2.0f} V 'vinduit' {ILLISIBLE} valeur r\u00e9gl\u00e9e \u00e0 {values['va']/0.98:2.0f} V 'Idn' {ILLISIBLE} valeur r\u00e9gl\u00e9e \u00e0 {values['idn']} mA 'retard_diff' {ILLISIBLE} {VALUE_SET_TO} {values['retard_diff']} ms 'retard_rth' {ILLISIBLE} valeur r\u00e9gl\u00e9e \u00e0 {values['retard_rth']} s 'retard' {ILLISIBLE} valeur r\u00e9gl\u00e9e \u00e0 {values['retard']} ms 'Ith' {ILLISIBLE} {VALUE_SET_TO} {values['ith']} A 'In' {ILLISIBLE} valeur r\u00e9gl\u00e9e \u00e0 {values['in']} A 'Pn' {ILLISIBLE} valeur r\u00e9gl\u00e9e \u00e0 {values['pn']} W 'vn' {ILLISIBLE} valeur r\u00e9gl\u00e9e \u00e0 {values['vn']} V 'couleur' {ILLISIBLE} valeur r\u00e9gl\u00e9e \u00e0 'rouge' 'vn' {ILLISIBLE} valeur r\u00e9gl\u00e9e \u00e0 24 V 'ton' {ILLISIBLE} valeur r\u00e9gl\u00e9e \u00e0 1s 'toff' {ILLISIBLE} valeur r\u00e9gl\u00e9e \u00e0 1s 'output_type' {ILLISIBLE} (output_type = V ou I), 'output_type' r\u00e9gl\u00e9 sur 'V' 'output_type' {ILLISIBLE} (output_type = V ou I), 'output_type' r\u00e9gl\u00e9 sur 'V' 'output_range' {ILLISIBLE} valeur r\u00e9gl\u00e9e \u00e0 (4,20) mA 'output_range' {ILLISIBLE} valeur r\u00e9gl\u00e9e \u00e0 (0,10) V 'output_scale' {ILLISIBLE} valeur r\u00e9gl\u00e9e \u00e0 (0,1000) 'input_type' {ILLISIBLE} (input_type = V ou I), 'input_type' r\u00e9gl\u00e9 sur 'V' 'input_type' {ILLISIBLE} (input_type = V ou I), 'input_type' r\u00e9gl\u00e9 sur 'V' 'input_range' {ILLISIBLE} valeur r\u00e9gl\u00e9e \u00e0 (4,20) mA 'input_range' {ILLISIBLE} valeur r\u00e9gl\u00e9e \u00e0 (0,10) V 'input_scale' {ILLISIBLE} valeur r\u00e9gl\u00e9e \u00e0 (0,1000) 'v' {ILLISIBLE} valeur r\u00e9gl\u00e9e \u00e0 {values['vn']} V 'voltage_range' {ILLISIBLE} valeur r\u00e9gl\u00e9e \u00e0 (0,10) V 'current_range' {ILLISIBLE} valeur r\u00e9gl\u00e9e \u00e0 (4,20) mA 'pression' {ILLISIBLE} valeur r\u00e9gl\u00e9e \u00e0 {values['pression']} bar 've' {ILLISIBLE} valeur r\u00e9gl\u00e9e \u00e0 {values['vin']} V 'vs' {ILLISIBLE} valeur r\u00e9gl\u00e9e \u00e0 {values['vout']} V 'vs1' {ILLISIBLE} valeur r\u00e9gl\u00e9e \u00e0 {values['vout1']} V 'vs2' {ILLISIBLE} valeur r\u00e9gl\u00e9e \u00e0 {values['vout2']} V 'vbat' {ILLISIBLE} valeur r\u00e9gl\u00e9e \u00e0 {values['vbat']} V 'format' {ILLISIBLE} (format = ac ou dc), 'format' r\u00e9gl\u00e9 sur 'dc' {power} {ILLISIBLE} valeur r\u00e9gl\u00e9e \u00e0 {values[{power}]/1000} kW param\u00e8tre {k} {ILLISIBLE} valeur d'usine {values[k]} {limits[k][0]} choisie","title":"Avertissements non bloquants"},{"location":"fr/grapher/","text":"Grapheur Ce module permet de dessiner un chronogramme (jusqu'\u00e0 16 variables) pendant la simulation : Il faut pr\u00e9alablement pr\u00e9parer la liste des variables \u00e0 visualiser dans une zone texte \u00e9dit\u00e9e dans WinRelais, par exemple : ( 19 - demo_Variateur_ATV31_triphas\u00e9_3C.xrs ) Il faut que la premi\u00e8re ligne de la zone de texte commence par le mot clef Grapheur , cette zone texte peut-\u00eatre plac\u00e9e librement dans le sch\u00e9ma, une icone sp\u00e9cifique apparait pendant la simulation si la zone texte Grapheur est d\u00e9tect\u00e9e, l'ordre des variables d\u00e9termine l'ordre d'affichage du chronogramme, la syntaxe utilis\u00e9e pour d\u00e9finir une variable est : nom_de_l'objet.commande[.calibre] commande description exemple state \u00e9tat actif/non actif fdc_haut.state : \u00e9tat du fin de course haut speed vitesse objet moteur M1.speed : vitesse du moteur M1 direction sens de rotation objet moteur M1.rotation : sens de rotation du moteur M1 value.calibre valeur mesur\u00e9e et calibre A1.value.10 : courant mesur\u00e9 par l'amp\u00e8rem\u00e8tre A1 calibr\u00e9 10 A","title":"Grapheur"},{"location":"fr/grapher/#grapheur","text":"Ce module permet de dessiner un chronogramme (jusqu'\u00e0 16 variables) pendant la simulation : Il faut pr\u00e9alablement pr\u00e9parer la liste des variables \u00e0 visualiser dans une zone texte \u00e9dit\u00e9e dans WinRelais, par exemple : ( 19 - demo_Variateur_ATV31_triphas\u00e9_3C.xrs ) Il faut que la premi\u00e8re ligne de la zone de texte commence par le mot clef Grapheur , cette zone texte peut-\u00eatre plac\u00e9e librement dans le sch\u00e9ma, une icone sp\u00e9cifique apparait pendant la simulation si la zone texte Grapheur est d\u00e9tect\u00e9e, l'ordre des variables d\u00e9termine l'ordre d'affichage du chronogramme, la syntaxe utilis\u00e9e pour d\u00e9finir une variable est : nom_de_l'objet.commande[.calibre] commande description exemple state \u00e9tat actif/non actif fdc_haut.state : \u00e9tat du fin de course haut speed vitesse objet moteur M1.speed : vitesse du moteur M1 direction sens de rotation objet moteur M1.rotation : sens de rotation du moteur M1 value.calibre valeur mesur\u00e9e et calibre A1.value.10 : courant mesur\u00e9 par l'amp\u00e8rem\u00e8tre A1 calibr\u00e9 10 A","title":"Grapheur"},{"location":"fr/hmi/","text":"Interface Homme Machine Les composants ihm sont modifiables dans WinSymbole. On peut cr\u00e9er des variantes de composants ihm en ajoutant le suffixe #ma_variante apr\u00e8s la racine du composant. Exemple : Voyant voyant biblioth\u00e8que /_ihm nom_texture = texture premier plan au format png nom_texture2 = texture arri\u00e8re-plan optionnelle au format png Bouton poussoir / Bouton glissi\u00e8re bouton_poussoir, bouton_glissiere biblioth\u00e8que /_ihm accrochage = False/True nom_texture = texture premier plan au format png nom_texture2 = texture arri\u00e8re-plan optionnelle au format png state = fixe l'\u00e9tat actif/non actif du bouton, seulement si accrochage = True Commutateur commutateur_2pos, commutateur_3pos biblioth\u00e8que /_ihm accrochage = False/True nom_texture = texture premier plan au format png nom_texture2 = texture arri\u00e8re-plan optionnelle au format png state = 0,1,2 : position du commutateur, seulement si accrochage = True Potentiom\u00e8tre bouton_tournant, bouton_lineaire_horizontal, bouton_lineaire_vertical biblioth\u00e8que /_ihm alpha = [0 \u00e0 100%] nom_texture = texture premier plan au format png nom_texture2 = texture arri\u00e8re-plan optionnelle au format png * fixe la position d'affichage du % r\u00e9gl\u00e9 par le bouton Composition Les composants simulables r\u00e9glables doivent \u00eatre associ\u00e9s \u00e0 un composant ihm. Biblioth\u00e8que _divers_pneumatique : Biblioth\u00e8que _capteurs Biblioth\u00e8que _r\u00e9sistances - L'association d'un composant ihm n'est pas obligatoire pour les composants r\u00e9sistances","title":"Interface Homme machine"},{"location":"fr/hmi/#interface-homme-machine","text":"Les composants ihm sont modifiables dans WinSymbole. On peut cr\u00e9er des variantes de composants ihm en ajoutant le suffixe #ma_variante apr\u00e8s la racine du composant. Exemple :","title":"Interface Homme Machine"},{"location":"fr/hmi/#voyant","text":"voyant biblioth\u00e8que /_ihm nom_texture = texture premier plan au format png nom_texture2 = texture arri\u00e8re-plan optionnelle au format png","title":"Voyant"},{"location":"fr/hmi/#bouton-poussoir-bouton-glissiere","text":"bouton_poussoir, bouton_glissiere biblioth\u00e8que /_ihm accrochage = False/True nom_texture = texture premier plan au format png nom_texture2 = texture arri\u00e8re-plan optionnelle au format png state = fixe l'\u00e9tat actif/non actif du bouton, seulement si accrochage = True","title":"Bouton poussoir / Bouton glissi\u00e8re"},{"location":"fr/hmi/#commutateur","text":"commutateur_2pos, commutateur_3pos biblioth\u00e8que /_ihm accrochage = False/True nom_texture = texture premier plan au format png nom_texture2 = texture arri\u00e8re-plan optionnelle au format png state = 0,1,2 : position du commutateur, seulement si accrochage = True","title":"Commutateur"},{"location":"fr/hmi/#potentiometre","text":"bouton_tournant, bouton_lineaire_horizontal, bouton_lineaire_vertical biblioth\u00e8que /_ihm alpha = [0 \u00e0 100%] nom_texture = texture premier plan au format png nom_texture2 = texture arri\u00e8re-plan optionnelle au format png * fixe la position d'affichage du % r\u00e9gl\u00e9 par le bouton","title":"Potentiom\u00e8tre"},{"location":"fr/hmi/#composition","text":"Les composants simulables r\u00e9glables doivent \u00eatre associ\u00e9s \u00e0 un composant ihm. Biblioth\u00e8que _divers_pneumatique : Biblioth\u00e8que _capteurs Biblioth\u00e8que _r\u00e9sistances - L'association d'un composant ihm n'est pas obligatoire pour les composants r\u00e9sistances","title":"Composition"},{"location":"fr/library/","text":"Biblioth\u00e8que simulable Accessibilit\u00e9 WinRelais expose la biblioth\u00e8que des composants simulables (dossier D4) selon trois m\u00e9thodes : L'explorateur permet d'acc\u00e9der facilement au dossier blocs_simulables qui permet de r\u00e9cup\u00e9rer des sous-ensembles de simulation complets : M\u00e9thode 1 : placer un symbole M\u00e9thode 2 : chercher et placer un symbole Explorateur : explorer et placer un symbole par glisser-d\u00e9poser Cr\u00e9er un symbole \u00e0 partir d'un symbole existant Il est possible de d\u00e9cliner un nouveau symbole \u00e0 partir d'un symbole existant pour adapter son dessin et la disposition des bornes selon les besoins. Le nouveau symbole h\u00e9ritera de toute la logique de simulation du symbole p\u00e8re. Le visuel du symbole peut-\u00eatre d\u00e9fini avec WinSymbole ou avec une image (appel\u00e9e aussi texture) au format png. Contraintes : Le nom des broches ne doit pas \u00eatre modifi\u00e9. Le nombre de broches ne doit pas changer. Exemple 1 : On souhaite cr\u00e9er un symbole d'amp\u00e8rem\u00e8tre de forme carr\u00e9e. Placer le symbole 'amperemetre' sur le folio. Aller dans Modifier un symbole\\Avanc\u00e9\\Ex\u00e9cuter WinSymbole. Modifier le symbole \u00e0 sa convenance dans WinSymbole. Enregistrer la modification (Ctrl-S). Accepter les modifications. Sauver le symbole dans la biblioth\u00e8que '_InstrumentsDeMesure' en le nommant 'amperemetre # carre'. (Ne pas utiliser de caract\u00e8res accentu\u00e9s pour nommer les symboles) Il est tr\u00e8s important de garder le m\u00eame nom de d\u00e9part, 'amperemetre' dans l'exemple, puis d'ajouter le caract\u00e8re ' # ' suivi du nom de son choix. Le symbole ' # ' indique au simulateur que le nouveau symbole 'carre' est une d\u00e9clinaison du symbole 'amperemetre'. Exemple 2 : On souhaite ajouter un symbole d'\u00e9lectrovanne \u00e0 la famille ' _Bobines' qu'on appellera ' electrovanne#1 '. L'op\u00e9ration est plus longue que dans l'exemple pr\u00e9c\u00e9dent car il faut cr\u00e9er le dessin du symbole quand il est actif. Le dessin des symboles actifs sont rang\u00e9s dans le fichier : C:\\Users\\Public\\Documents\\Elec-CAO\\wrs-data\\wrs-on-symbols.xrs Placer le symbole ' electrovanne ' de la famille ' _Bobines' sur le folio. Modifier le symbole comme dit aux points 2.3 et 4 de l'exemple 1. Sauver le symbole dans la biblioth\u00e8que '' _Bobines en le nommant ' electrovanne #1 '. Ouvrir le sch\u00e9ma ' wrs-on-symbols.xrs' dans WinRelais. S\u00e9lectionner de pr\u00e9f\u00e9rence le folio '_bobines' . Placer le symbole fraichement enregistr\u00e9 ' electrovanne #1 ' sur le folio. Aller dans Modifier un symbole\\Avanc\u00e9\\Ex\u00e9cuter WinSymbole. Modifier le symbole \u00e0 sa convenance dans WinSymbole. Enregistrer la modification (Ctrl-S). Accepter les modifications. Enregistrer le sch\u00e9ma ' wrs-on-symbols.xrs '. Exemple 3 : Utilisation d'une image au format png pour cr\u00e9er le visuel d'une electrovanne qui sera nomm\u00e9e ' electrovanne #2 ' On peut trouver que les possibilit\u00e9s de dessin de WinSymbole ne sont pas suffisantes pour cr\u00e9er le visuel des symboles. Il est alors possible d'utiliser une texture qui sera \u00e9dit\u00e9e dans un logiciel \u00e0 part. Le visuel de l'objet 'electrovanne' initial manipul\u00e9 pr\u00e9c\u00e9demment est construit avec cette texture : Placer le symbole ' electrovanne ' de la famille ' _Bobines' sur le folio. Sauver le symbole dans la biblioth\u00e8que '' _Bobines en le nommant ' electrovanne #2 '. Acc\u00e9der \u00e0 la texture 'electrovanne.png' pr\u00e9sente dans le dossier :\\ C:\\Users\\Public\\Documents\\Elec-CAO\\wrs-data\\sym_textures\\_Bobines\\Electrovanne.png Copier dans le m\u00eame dossier la texture renomme en ' electrovanne#2.png' Editer la texture ' electrovanne#2.png' dans un logiciel ad\u00e9quat, (GIMP par exemple) selon les besoins, puis enregistrer. (commande 'Ecraser electrovanne#2.png' avec GIMP) Mode(s) de dessin par famille de symboles Famille Mode(s) de dessin \\_API WinSymbole seulement \\_Bobines Texture ou WinSymbole \\_Bornes Texture ou WinSymbole \\_Boutons Texture ou WinSymbole \\ _Contacteurs WinSymbole seulement \\_Contacts_Commande Texture ou WinSymbole \\_Detecteurs Texture ou WinSymbole \\_Disjoncteurs WinSymbole seulement \\_Divers_Pneumatiques WinSymbole seulement \\_Fins_De_Course Texture ou WinSymbole \\_Grafcet WinSymbole seulement \\_Intruments_de_Mesure WinSymbole seulement \\_Interrupteurs_Sectionneurs WinSymbole seulement \\_Masses+Terres WinSymbole seulement \\_Moteurs_Alternatifs WinSymbole seulement \\_Moteurs_Continus WinSymbole seulement \\_Relais_Thermiques WinSymbole seulement \\_Resistances WinSymbole seulement \\_Sectionneurs_Porte_Fusibles WinSymbole seulement \\_Signalisation Texture ou WinSymbole \\_Sources Texture ou WinSymbole \\_Transformateurs WinSymbole seulement Un symbole qui poss\u00e8de le mode de dessin par d\u00e9faut 'WinSymbole' peut \u00eatre d\u00e9clin\u00e9 en en autre symbole uniquement avec WinSymbole. Un symbole qui poss\u00e8de le mode de dessin par d\u00e9faut 'Texture' peut-\u00eatre d\u00e9clin\u00e9 en un autre symbole avec une texture modifi\u00e9e, ou avec une description WinSymbole. Param\u00e9trage des composants g\u00e9n\u00e9raux (disponible dans 'Modifier un objet' dans WinRelais) Relais, relais temporis\u00e9, cadenceur biblioth\u00e8que _bobines vn = tension de la bobine [12 \u00e0 230 V] pn = puissance nominale [12 \u00e0 230 V] toff = retard \u00e0 la d\u00e9sactivation [0 \u00e0 30 s] ton = retard \u00e0 l'activation [0 \u00e0 30 s] Contacts temporis\u00e9s biblioth\u00e8que _contacts_commande toff = retard \u00e0 la d\u00e9sactivation [0 \u00e0 30 s] ton = retard \u00e0 l'activation [0 \u00e0 30 s] Signalisation biblioth\u00e8que _signalisation v = tension de la bobine [12 \u00e0 230 V] couleur = couleur du voyant [rouge, vert, bleu, orange, blanc] Disjoncteur + DDR biblioth\u00e8que _disjoncteurs In = calibre [0.5 \u00e0 100 A] retard = retard intentionnel [0 \u00e0 10000 ms] courbe = courbe de d\u00e9clenchement [B, C, D] idn = sensibilit\u00e9 du diff\u00e9rentiel [10 \u00e0 10000 mA] retard_diff = retard intentionnel du DDR [0 \u00e0 10000 ms] Fusible biblioth\u00e8que _sectionneurs_porte_fusibles In = calibre fusible [0.5 \u00e0 100 A] retard = retard intentionnel [0 \u00e0 10000 ms] type = type de cartouche [aM, gG] Relais thermique biblioth\u00e8que _relais_thermiques ith = seuil thermique [0.1 \u00e0 100 A] Moteur alternatif biblioth\u00e8que _moteurs_alternatifs Pu = puissance utile moteur [90 W \u00e0 22 kW] nm = vitesse nominale moteur [740 \u00e0 3000 rpm] cos = cos(phi) moteur [0.5 \u00e0 1] rendement = rendement moteur [0.5 \u00e0 1] venroulement = tension nominale aux bornes d'un enroulement [127 \u00e0 400 V] couplage = couplage moteur [\u00e9toile, triangle] Moteur continu biblioth\u00e8que _moteurs_continus pu = puissance utile moteur [90 W \u00e0 22 kW] nm = vitesse nominale moteur [740 \u00e0 3000 rpm] vinduit = tension d'induit [12 \u00e0 320 V] rendement = rendement moteur [0.5 \u00e0 1] Source, alimentation stabilis\u00e9e, transformateur biblioth\u00e8que \\ _sources pression = pression air comprim\u00e9 [0 \u00e0 10 bar] vin = tension d'entr\u00e9e [12 \u00e0 400 V] vout = tension de sortie [12 \u00e0 400 V] vout1 = tension de sortie [12 \u00e0 400 V] vout2 = tension de sortie [12 \u00e0 400 V] R\u00e9sistance de puissance biblioth\u00e8que _resistances pn = puissance nominale [10 W \u00e0 22 kW] venroulement = tension nominale aux bornes d'un enroulement [230 ou 400 V] Potentiom\u00e8tre biblioth\u00e8que _resistances valeur = r\u00e9sistance du potentiom\u00e8tre [1m \u00e0 10M ohms], (10m, 10, 10k, 2.2 M) alpha = position du curseur [0 \u00e0 100 %] R\u00e9sistance simple biblioth\u00e8que _resistances valeur = r\u00e9sistance [1m \u00e0 10M ohms], (10m, 10, 10k, 2.2 M) Instruments de mesure biblioth\u00e8que _instruments_de_mesure type = type de mesure [moyenne, efficace] ou [avg, rms] afficher ici permet de positionner la valeur de la mesure sur le folio * idem que afficher ici Signal\u00e9tique des composants \u00e9lectriques: Symboles utilis\u00e9s dans la simulation pour donner l'\u00e9tat des composants \u00e9lectriques : Protection \u00e9lectrique arm\u00e9e (disjoncteur et fusible) Ouverture protection \u00e9lectrique sur surcharge ou court-circuit (disjoncteur et fusible) Ouverture protection sur courant de fuite (DDR) Indicateur de l'\u00e9tat individuel de cartouches fusibles. Exemple sur un porte-fusible tripolaire avec deux cartouches fusibles fondues. R\u00e9cepteur sous-aliment\u00e9 R\u00e9cepteur suraliment\u00e9","title":"Biblioth\u00e8que simulable"},{"location":"fr/library/#bibliotheque-simulable","text":"","title":"Biblioth\u00e8que simulable"},{"location":"fr/library/#accessibilite","text":"WinRelais expose la biblioth\u00e8que des composants simulables (dossier D4) selon trois m\u00e9thodes : L'explorateur permet d'acc\u00e9der facilement au dossier blocs_simulables qui permet de r\u00e9cup\u00e9rer des sous-ensembles de simulation complets :","title":"Accessibilit\u00e9"},{"location":"fr/library/#methode-1-placer-un-symbole","text":"","title":"M\u00e9thode 1 : placer un symbole"},{"location":"fr/library/#methode-2-chercher-et-placer-un-symbole","text":"","title":"M\u00e9thode 2 : chercher et placer un symbole"},{"location":"fr/library/#explorateur-explorer-et-placer-un-symbole-par-glisser-deposer","text":"","title":"Explorateur : explorer et placer un symbole par glisser-d\u00e9poser"},{"location":"fr/library/#creer-un-symbole-a-partir-dun-symbole-existant","text":"Il est possible de d\u00e9cliner un nouveau symbole \u00e0 partir d'un symbole existant pour adapter son dessin et la disposition des bornes selon les besoins. Le nouveau symbole h\u00e9ritera de toute la logique de simulation du symbole p\u00e8re. Le visuel du symbole peut-\u00eatre d\u00e9fini avec WinSymbole ou avec une image (appel\u00e9e aussi texture) au format png. Contraintes : Le nom des broches ne doit pas \u00eatre modifi\u00e9. Le nombre de broches ne doit pas changer. Exemple 1 : On souhaite cr\u00e9er un symbole d'amp\u00e8rem\u00e8tre de forme carr\u00e9e. Placer le symbole 'amperemetre' sur le folio. Aller dans Modifier un symbole\\Avanc\u00e9\\Ex\u00e9cuter WinSymbole. Modifier le symbole \u00e0 sa convenance dans WinSymbole. Enregistrer la modification (Ctrl-S). Accepter les modifications. Sauver le symbole dans la biblioth\u00e8que '_InstrumentsDeMesure' en le nommant 'amperemetre # carre'. (Ne pas utiliser de caract\u00e8res accentu\u00e9s pour nommer les symboles) Il est tr\u00e8s important de garder le m\u00eame nom de d\u00e9part, 'amperemetre' dans l'exemple, puis d'ajouter le caract\u00e8re ' # ' suivi du nom de son choix. Le symbole ' # ' indique au simulateur que le nouveau symbole 'carre' est une d\u00e9clinaison du symbole 'amperemetre'. Exemple 2 : On souhaite ajouter un symbole d'\u00e9lectrovanne \u00e0 la famille ' _Bobines' qu'on appellera ' electrovanne#1 '. L'op\u00e9ration est plus longue que dans l'exemple pr\u00e9c\u00e9dent car il faut cr\u00e9er le dessin du symbole quand il est actif. Le dessin des symboles actifs sont rang\u00e9s dans le fichier : C:\\Users\\Public\\Documents\\Elec-CAO\\wrs-data\\wrs-on-symbols.xrs Placer le symbole ' electrovanne ' de la famille ' _Bobines' sur le folio. Modifier le symbole comme dit aux points 2.3 et 4 de l'exemple 1. Sauver le symbole dans la biblioth\u00e8que '' _Bobines en le nommant ' electrovanne #1 '. Ouvrir le sch\u00e9ma ' wrs-on-symbols.xrs' dans WinRelais. S\u00e9lectionner de pr\u00e9f\u00e9rence le folio '_bobines' . Placer le symbole fraichement enregistr\u00e9 ' electrovanne #1 ' sur le folio. Aller dans Modifier un symbole\\Avanc\u00e9\\Ex\u00e9cuter WinSymbole. Modifier le symbole \u00e0 sa convenance dans WinSymbole. Enregistrer la modification (Ctrl-S). Accepter les modifications. Enregistrer le sch\u00e9ma ' wrs-on-symbols.xrs '. Exemple 3 : Utilisation d'une image au format png pour cr\u00e9er le visuel d'une electrovanne qui sera nomm\u00e9e ' electrovanne #2 ' On peut trouver que les possibilit\u00e9s de dessin de WinSymbole ne sont pas suffisantes pour cr\u00e9er le visuel des symboles. Il est alors possible d'utiliser une texture qui sera \u00e9dit\u00e9e dans un logiciel \u00e0 part. Le visuel de l'objet 'electrovanne' initial manipul\u00e9 pr\u00e9c\u00e9demment est construit avec cette texture : Placer le symbole ' electrovanne ' de la famille ' _Bobines' sur le folio. Sauver le symbole dans la biblioth\u00e8que '' _Bobines en le nommant ' electrovanne #2 '. Acc\u00e9der \u00e0 la texture 'electrovanne.png' pr\u00e9sente dans le dossier :\\ C:\\Users\\Public\\Documents\\Elec-CAO\\wrs-data\\sym_textures\\_Bobines\\Electrovanne.png Copier dans le m\u00eame dossier la texture renomme en ' electrovanne#2.png' Editer la texture ' electrovanne#2.png' dans un logiciel ad\u00e9quat, (GIMP par exemple) selon les besoins, puis enregistrer. (commande 'Ecraser electrovanne#2.png' avec GIMP)","title":"Cr\u00e9er un symbole \u00e0 partir d'un symbole existant"},{"location":"fr/library/#modes-de-dessin-par-famille-de-symboles","text":"Famille Mode(s) de dessin \\_API WinSymbole seulement \\_Bobines Texture ou WinSymbole \\_Bornes Texture ou WinSymbole \\_Boutons Texture ou WinSymbole \\ _Contacteurs WinSymbole seulement \\_Contacts_Commande Texture ou WinSymbole \\_Detecteurs Texture ou WinSymbole \\_Disjoncteurs WinSymbole seulement \\_Divers_Pneumatiques WinSymbole seulement \\_Fins_De_Course Texture ou WinSymbole \\_Grafcet WinSymbole seulement \\_Intruments_de_Mesure WinSymbole seulement \\_Interrupteurs_Sectionneurs WinSymbole seulement \\_Masses+Terres WinSymbole seulement \\_Moteurs_Alternatifs WinSymbole seulement \\_Moteurs_Continus WinSymbole seulement \\_Relais_Thermiques WinSymbole seulement \\_Resistances WinSymbole seulement \\_Sectionneurs_Porte_Fusibles WinSymbole seulement \\_Signalisation Texture ou WinSymbole \\_Sources Texture ou WinSymbole \\_Transformateurs WinSymbole seulement Un symbole qui poss\u00e8de le mode de dessin par d\u00e9faut 'WinSymbole' peut \u00eatre d\u00e9clin\u00e9 en en autre symbole uniquement avec WinSymbole. Un symbole qui poss\u00e8de le mode de dessin par d\u00e9faut 'Texture' peut-\u00eatre d\u00e9clin\u00e9 en un autre symbole avec une texture modifi\u00e9e, ou avec une description WinSymbole.","title":"Mode(s) de dessin par famille de symboles"},{"location":"fr/library/#parametrage-des-composants-generaux","text":"(disponible dans 'Modifier un objet' dans WinRelais) Relais, relais temporis\u00e9, cadenceur biblioth\u00e8que _bobines vn = tension de la bobine [12 \u00e0 230 V] pn = puissance nominale [12 \u00e0 230 V] toff = retard \u00e0 la d\u00e9sactivation [0 \u00e0 30 s] ton = retard \u00e0 l'activation [0 \u00e0 30 s] Contacts temporis\u00e9s biblioth\u00e8que _contacts_commande toff = retard \u00e0 la d\u00e9sactivation [0 \u00e0 30 s] ton = retard \u00e0 l'activation [0 \u00e0 30 s] Signalisation biblioth\u00e8que _signalisation v = tension de la bobine [12 \u00e0 230 V] couleur = couleur du voyant [rouge, vert, bleu, orange, blanc] Disjoncteur + DDR biblioth\u00e8que _disjoncteurs In = calibre [0.5 \u00e0 100 A] retard = retard intentionnel [0 \u00e0 10000 ms] courbe = courbe de d\u00e9clenchement [B, C, D] idn = sensibilit\u00e9 du diff\u00e9rentiel [10 \u00e0 10000 mA] retard_diff = retard intentionnel du DDR [0 \u00e0 10000 ms] Fusible biblioth\u00e8que _sectionneurs_porte_fusibles In = calibre fusible [0.5 \u00e0 100 A] retard = retard intentionnel [0 \u00e0 10000 ms] type = type de cartouche [aM, gG] Relais thermique biblioth\u00e8que _relais_thermiques ith = seuil thermique [0.1 \u00e0 100 A] Moteur alternatif biblioth\u00e8que _moteurs_alternatifs Pu = puissance utile moteur [90 W \u00e0 22 kW] nm = vitesse nominale moteur [740 \u00e0 3000 rpm] cos = cos(phi) moteur [0.5 \u00e0 1] rendement = rendement moteur [0.5 \u00e0 1] venroulement = tension nominale aux bornes d'un enroulement [127 \u00e0 400 V] couplage = couplage moteur [\u00e9toile, triangle] Moteur continu biblioth\u00e8que _moteurs_continus pu = puissance utile moteur [90 W \u00e0 22 kW] nm = vitesse nominale moteur [740 \u00e0 3000 rpm] vinduit = tension d'induit [12 \u00e0 320 V] rendement = rendement moteur [0.5 \u00e0 1] Source, alimentation stabilis\u00e9e, transformateur biblioth\u00e8que \\ _sources pression = pression air comprim\u00e9 [0 \u00e0 10 bar] vin = tension d'entr\u00e9e [12 \u00e0 400 V] vout = tension de sortie [12 \u00e0 400 V] vout1 = tension de sortie [12 \u00e0 400 V] vout2 = tension de sortie [12 \u00e0 400 V] R\u00e9sistance de puissance biblioth\u00e8que _resistances pn = puissance nominale [10 W \u00e0 22 kW] venroulement = tension nominale aux bornes d'un enroulement [230 ou 400 V] Potentiom\u00e8tre biblioth\u00e8que _resistances valeur = r\u00e9sistance du potentiom\u00e8tre [1m \u00e0 10M ohms], (10m, 10, 10k, 2.2 M) alpha = position du curseur [0 \u00e0 100 %] R\u00e9sistance simple biblioth\u00e8que _resistances valeur = r\u00e9sistance [1m \u00e0 10M ohms], (10m, 10, 10k, 2.2 M) Instruments de mesure biblioth\u00e8que _instruments_de_mesure type = type de mesure [moyenne, efficace] ou [avg, rms] afficher ici permet de positionner la valeur de la mesure sur le folio * idem que afficher ici","title":"Param\u00e9trage des composants g\u00e9n\u00e9raux"},{"location":"fr/library/#signaletique-des-composants-electriques","text":"Symboles utilis\u00e9s dans la simulation pour donner l'\u00e9tat des composants \u00e9lectriques : Protection \u00e9lectrique arm\u00e9e (disjoncteur et fusible) Ouverture protection \u00e9lectrique sur surcharge ou court-circuit (disjoncteur et fusible) Ouverture protection sur courant de fuite (DDR) Indicateur de l'\u00e9tat individuel de cartouches fusibles. Exemple sur un porte-fusible tripolaire avec deux cartouches fusibles fondues. R\u00e9cepteur sous-aliment\u00e9 R\u00e9cepteur suraliment\u00e9","title":"Signal\u00e9tique des composants \u00e9lectriques:"},{"location":"fr/modbus/","text":"Modbus/Tcp-IP Pr\u00e9ambule Le simulateur int\u00e8gre le protocole bus de terrain MODBUS/TCP-IP qui est une variante du MODBUS s\u00e9rie propos\u00e9 par la soci\u00e9t\u00e9 MODICON depuis 1979. La variante TCP-IP encapsule le protocole MODBUS dans le protocole Ethernet. Cette encapsulation permet aux constructeurs d'utiliser MODBUS sur toute l'infrastructure mat\u00e9rielle Ethernet MODBUS TCP-IP pr\u00e9sente des avantages d\u00e9terminants : c'est le protocole Ethernet Industriel le plus employ\u00e9 dans le monde, les sp\u00e9cifications sont facilement disponibles, il est taill\u00e9 pour r\u00e9aliser l'\u00e9change rapide de petites quantit\u00e9s de donn\u00e9es. Codes fonction MODBUS support\u00e9s code 03 (0x03) Read Holding Registers Ce code de fonction est utilis\u00e9 pour lire le contenu d'un bloc contigu de registres de la m\u00e9moire automate. La requ\u00eate sp\u00e9cifie l'adresse du registre de d\u00e9part et le nombre de registres. Dans la requ\u00eate, les registres sont adress\u00e9s en commen\u00e7ant \u00e0 z\u00e9ro. Ainsi, les registres num\u00e9rot\u00e9s de 1 \u00e0 16 sont adress\u00e9s comme 0 \u00e0 15. Les donn\u00e9es des registres dans le message de r\u00e9ponse sont compact\u00e9es sous forme de deux octets par registre, avec le contenu binaire justifi\u00e9 \u00e0 droite dans chaque octet. Pour chaque registre, le premier octet contient les bits de poids fort et le second contient les bits de poids faible . code 16 (0x10) Write Multiple Registers Ce code de fonction est utilis\u00e9 pour \u00e9crire un bloc de registres contigus (1 \u00e0 123 registres) dans dans la m\u00e9moire automate.Les valeurs \u00e0 \u00e9crire sont sp\u00e9cifi\u00e9es dans le champ de donn\u00e9es de la requ\u00eate. Les donn\u00e9es sont compact\u00e9es sous forme de deux octets par registre. La r\u00e9ponse normale renvoie le code de fonction, l'adresse de d\u00e9part, et la quantit\u00e9 de registres \u00e9crits. code 23 (0x17) Read/Write Multiple Registers Ce code de fonction effectue une combinaison d'une op\u00e9ration de lecture et d'une op\u00e9ration d'\u00e9criture dans une seule transaction MODBUS. L'op\u00e9ration d'\u00e9criture est effectu\u00e9e avant l'op\u00e9ration de lecture. Les registres de la m\u00e9moire automate sont adress\u00e9s en commen\u00e7ant \u00e0 z\u00e9ro. Ainsi, les registres 1 \u00e0 16 sont adress\u00e9s dans l'automate comme 0 \u00e0 15. La requ\u00eate sp\u00e9cifie l'adresse de d\u00e9part et le nombre de registres de la m\u00e9moire automate \u00e0 lire, ainsi que l'adresse de d\u00e9part, le nombre de registres de la m\u00e9moire automate et les donn\u00e9es \u00e0 \u00e9crire. Le champ WriteByteCount sp\u00e9cifie le nombre d'octets qui suivent dans le champ de donn\u00e9es \u00e0 \u00e9crire. La r\u00e9ponse normale contient les donn\u00e9es du groupe de registres qui ont \u00e9t\u00e9 lus. Le champ ByteCount sp\u00e9cifie la quantit\u00e9 d'octets \u00e0 suivre dans le champ de donn\u00e9es lues. Mappage MODBUS Configuration MODBUS adresse_ip localhost/127.0.0.1/192.168.0.10 adresse IP du serveur API port 502 port normalis\u00e9 MODBUS ID_unite 111 identifiant du client adresse_table_echange 400 pointeur sur la table d'\u00e9change Si l'objet de configuration MODBUS n'est pas plac\u00e9 dans votre projet, les valeurs utilis\u00e9es par d\u00e9faut sont : adresse_ip = local_host, port = 502, adresse_table_echange = 400 et ID_unite = 111. L'objet de configuration MODBUS est requis uniquement lorsqu'un automate programmable est pr\u00e9sent dans un folio.","title":"Modbus TCP-IP"},{"location":"fr/modbus/#preambule","text":"Le simulateur int\u00e8gre le protocole bus de terrain MODBUS/TCP-IP qui est une variante du MODBUS s\u00e9rie propos\u00e9 par la soci\u00e9t\u00e9 MODICON depuis 1979. La variante TCP-IP encapsule le protocole MODBUS dans le protocole Ethernet. Cette encapsulation permet aux constructeurs d'utiliser MODBUS sur toute l'infrastructure mat\u00e9rielle Ethernet MODBUS TCP-IP pr\u00e9sente des avantages d\u00e9terminants : c'est le protocole Ethernet Industriel le plus employ\u00e9 dans le monde, les sp\u00e9cifications sont facilement disponibles, il est taill\u00e9 pour r\u00e9aliser l'\u00e9change rapide de petites quantit\u00e9s de donn\u00e9es.","title":"Pr\u00e9ambule"},{"location":"fr/modbus/#codes-fonction-modbus-supportes","text":"code 03 (0x03) Read Holding Registers Ce code de fonction est utilis\u00e9 pour lire le contenu d'un bloc contigu de registres de la m\u00e9moire automate. La requ\u00eate sp\u00e9cifie l'adresse du registre de d\u00e9part et le nombre de registres. Dans la requ\u00eate, les registres sont adress\u00e9s en commen\u00e7ant \u00e0 z\u00e9ro. Ainsi, les registres num\u00e9rot\u00e9s de 1 \u00e0 16 sont adress\u00e9s comme 0 \u00e0 15. Les donn\u00e9es des registres dans le message de r\u00e9ponse sont compact\u00e9es sous forme de deux octets par registre, avec le contenu binaire justifi\u00e9 \u00e0 droite dans chaque octet. Pour chaque registre, le premier octet contient les bits de poids fort et le second contient les bits de poids faible . code 16 (0x10) Write Multiple Registers Ce code de fonction est utilis\u00e9 pour \u00e9crire un bloc de registres contigus (1 \u00e0 123 registres) dans dans la m\u00e9moire automate.Les valeurs \u00e0 \u00e9crire sont sp\u00e9cifi\u00e9es dans le champ de donn\u00e9es de la requ\u00eate. Les donn\u00e9es sont compact\u00e9es sous forme de deux octets par registre. La r\u00e9ponse normale renvoie le code de fonction, l'adresse de d\u00e9part, et la quantit\u00e9 de registres \u00e9crits. code 23 (0x17) Read/Write Multiple Registers Ce code de fonction effectue une combinaison d'une op\u00e9ration de lecture et d'une op\u00e9ration d'\u00e9criture dans une seule transaction MODBUS. L'op\u00e9ration d'\u00e9criture est effectu\u00e9e avant l'op\u00e9ration de lecture. Les registres de la m\u00e9moire automate sont adress\u00e9s en commen\u00e7ant \u00e0 z\u00e9ro. Ainsi, les registres 1 \u00e0 16 sont adress\u00e9s dans l'automate comme 0 \u00e0 15. La requ\u00eate sp\u00e9cifie l'adresse de d\u00e9part et le nombre de registres de la m\u00e9moire automate \u00e0 lire, ainsi que l'adresse de d\u00e9part, le nombre de registres de la m\u00e9moire automate et les donn\u00e9es \u00e0 \u00e9crire. Le champ WriteByteCount sp\u00e9cifie le nombre d'octets qui suivent dans le champ de donn\u00e9es \u00e0 \u00e9crire. La r\u00e9ponse normale contient les donn\u00e9es du groupe de registres qui ont \u00e9t\u00e9 lus. Le champ ByteCount sp\u00e9cifie la quantit\u00e9 d'octets \u00e0 suivre dans le champ de donn\u00e9es lues.","title":"Codes fonction MODBUS support\u00e9s"},{"location":"fr/modbus/#mappage-modbus","text":"","title":"Mappage MODBUS"},{"location":"fr/modbus/#configuration-modbus","text":"adresse_ip localhost/127.0.0.1/192.168.0.10 adresse IP du serveur API port 502 port normalis\u00e9 MODBUS ID_unite 111 identifiant du client adresse_table_echange 400 pointeur sur la table d'\u00e9change Si l'objet de configuration MODBUS n'est pas plac\u00e9 dans votre projet, les valeurs utilis\u00e9es par d\u00e9faut sont : adresse_ip = local_host, port = 502, adresse_table_echange = 400 et ID_unite = 111. L'objet de configuration MODBUS est requis uniquement lorsqu'un automate programmable est pr\u00e9sent dans un folio.","title":"Configuration MODBUS"},{"location":"fr/plc/","text":"Automate programmable Pr\u00e9ambule Le simulateur permet d'int\u00e9grer un automate programmable physique ou virtuel dans un folio. La communication avec l'API est r\u00e9alis\u00e9e en utilisant le protocole Modbus/Tcp-IP : avec l'adresse IP locale (127.0.0.1) du serveur Modbus int\u00e9gr\u00e9 \u00e0 l'API virtuel, avec l'adresse IP statique du serveur Modbus int\u00e9gr\u00e9 \u00e0 l'API physique connect\u00e9 sur un r\u00e9seau Ethernet. Cette solution permet d'utiliser les outils de programmation habituels des automates. Logique d'\u00e9change client (master) (simulateur) <-> serveur (slave) (api) , p\u00e9riodiquement : le client Modbus (simulateur) \u00e9met une requ\u00eate d'\u00e9criture des entr\u00e9es du SAP simul\u00e9 au serveur Modbus (API), l'API calcule l'\u00e9tat des sorties du SAP selon son programme et l'\u00e9tat des entr\u00e9es re\u00e7ues, le client Modbus (simulateur) \u00e9met une requ\u00eate de lecture des sorties calcul\u00e9es par le programme au serveur Modbus (API), le simulateur met \u00e0 jour l'\u00e9tat du SAP. Automates test\u00e9s : M221 Schneider Electric codes fonctions 3,16 et 23, serveur modbus int\u00e9gr\u00e9 M340 Schneider Electric code fonctions 3 et 16, serveur modbus int\u00e9gr\u00e9 Unilogic Unitronics codes fonctions 3,16 et 23, configuration du serveur Modbus requise : L'exemple ci-dessous utilise EcoStruxure Basic Expert de SchneiderElectric qui permet la programmation et la simulation des automates de la famille M221. Exemple ascenseur (fichiers 15-demo_ascenseur_M221.xrs et 15-demo_ascenseur_M221.smbp) Pr\u00e9paration c\u00f4t\u00e9 WRsimulateur : La commande de l'ascenseur n\u00e9cessite 8 entr\u00e9es et 4 sorties TOR. On peut utiliser un M221 type TM221CE16R qui dispose de 9 entr\u00e9es TOR et de 7 sorties \u00e0 relais. Adressage des entr\u00e9es TOR : %I0.0, %I0.1, %I0.2, %I0.3, %I0.4, %I0.5, %I0.6, %I0.7, %I0.8 Adressage des sorties : %Q0.0, %Q0.1, %Q0.2, %Q0.3, %Q0.4, %Q0.5, %Q0.6 L'exemple \u00e9tudi\u00e9 implante 8 objets d'entr\u00e9e et 4 objets de sortie en les identifiant avec les adresses API standards. Affectation des entr\u00e9es adresse mn\u00e9monique commentaire %I0.0 E3 appel \u00e9tage 3 %I0.1 E2 appel \u00e9tage 2 %I0.2 E1 appel \u00e9tage 1 %I0.3 P1 cabine \u00e0 l\u00e9tage 1 %I0.4 P2 cabine \u00e0 l\u00e9tage 2 %I0.5 P3 cabine \u00e0 l\u00e9tage 3 %I0.6 PF porte cabine ferm\u00e9e %I0.7 PO porte cabine ouverte Affectation des sorties adresse mn\u00e9monique commentaire %Q0.0 OUVRIR Ouvrir porte %Q0.1 FERMER Fermer porte %Q0.2 DESCENDRE Descendre cage %Q0.3 MONTER Monter cage Pr\u00e9paration c\u00f4t\u00e9 EcoStruxure Machine Expert--Basic Le programme complet 15-demo_ascenseur_M221.smbp est disponible dans le dossier : Mise en correspondance des tableaux d'entr\u00e9es/sorties avec la table d'\u00e9change ajust\u00e9e sur l'adresse de d\u00e9part %MW400 voir le mappage modbus : adresse mappage MODBUS mn\u00e9monique commentaire %I0.0 %MW500 :X0 E3 appel \u00e9tage 3 %I0.1 %MW500 :X1 E2 appel \u00e9tage 2 %I0.2 %MW500 :X2 E1 appel \u00e9tage 1 %I0.3 %MW500 :X3 P1 cabine \u00e0 l\u00e9tage 1 %I0.4 %MW500 :X4 P2 cabine \u00e0 l\u00e9tage 2 %I0.5 %MW500 :X5 P3 cabine \u00e0 l\u00e9tage 3 %I0.6 %MW500 :X6 PF porte cabine ferm\u00e9e %I0.7 %MW500 :X7 PO porte cabine ouverte adresse mappage MODBUS mn\u00e9monique commentaire %Q0.0 %MW400 :X0 OUVRIR Ouvrir porte %Q0.1 %MW400 :X1 FERMER Fermer porte %Q0.2 %MW400 :X2 DESCENDRE Descendre cage %Q0.3 %MW401 :X3 MONTER Monter cage Dans l'onglet Programmation ->Outils -> Liste de symboles , on trouve l'assignation des entr\u00e9es/sorties qui correspond aux tableaux pr\u00e9c\u00e9dents: Programme API : D\u00e9marrer le contr\u00f4leur AVANT de lancer le simulateur en activant les boutons Lancer le simulateur et D\u00e9marrer le contr\u00f4leur dans l'onglet Mise en service d'EcoStruxure: Construction d'un objet API Un automate est construit avec les objets \u00e9l\u00e9mentaires : input# pour les entr\u00e9es TOR, output# pour les sorties TOR, analog_input# pour les entr\u00e9es analogiques, analog_output# pour les sorties analogiques, plc_supply# pour l'alimentation de l'API Toutes les E/S ont pour parent l'objet plc_supply afin d'asservir l'alimentation de ces E/S \u00e0 l'alimentation de l'automate. Le serveur MODBUS est implicitement attach\u00e9 \u00e0 l'automate en place dans le sch\u00e9ma. On ne peut placer qu'un seul automate dans le sch\u00e9ma. Des exemples d'automates sont disponibles dans le dossier blocs_simulables \u00e0 partir de la commande 'Ouvrir un bloc' de WinRelais. Toutes ces empreintes d'automate sont ajustables et modifiables selon les besoins. Entr\u00e9es/Sorties logiques input, output biblioth\u00e8que _api %Ir.v ou %Qr.v r = [0,5] v = [0,31] parent = nom de l'objet plc_supply# Entr\u00e9es analogiques analog_input biblioth\u00e8que _api %IWr.v r = [0,5] v = [0,3] parent = nom de l'objet plc_supply# input_type = U ou I input_range = (min,max) V [-10,10] V ou (min,max) mA [0, 20] mA input_scale = min,max [-32768, 32767] Sorties analogiques analog_output biblioth\u00e8que _api %QW0.0 r = [0,5] v = [0,3] parent = nom de l'objet plc_supply# output_type = U ou I output_range = (min,max) V [-10,10] V ou (min,max) mA [0, 20] mA output_scale = min,max [-32768, 32767]","title":"Automate programmable"},{"location":"fr/plc/#automate-programmable","text":"","title":"Automate programmable"},{"location":"fr/plc/#preambule","text":"Le simulateur permet d'int\u00e9grer un automate programmable physique ou virtuel dans un folio. La communication avec l'API est r\u00e9alis\u00e9e en utilisant le protocole Modbus/Tcp-IP : avec l'adresse IP locale (127.0.0.1) du serveur Modbus int\u00e9gr\u00e9 \u00e0 l'API virtuel, avec l'adresse IP statique du serveur Modbus int\u00e9gr\u00e9 \u00e0 l'API physique connect\u00e9 sur un r\u00e9seau Ethernet. Cette solution permet d'utiliser les outils de programmation habituels des automates. Logique d'\u00e9change client (master) (simulateur) <-> serveur (slave) (api) , p\u00e9riodiquement : le client Modbus (simulateur) \u00e9met une requ\u00eate d'\u00e9criture des entr\u00e9es du SAP simul\u00e9 au serveur Modbus (API), l'API calcule l'\u00e9tat des sorties du SAP selon son programme et l'\u00e9tat des entr\u00e9es re\u00e7ues, le client Modbus (simulateur) \u00e9met une requ\u00eate de lecture des sorties calcul\u00e9es par le programme au serveur Modbus (API), le simulateur met \u00e0 jour l'\u00e9tat du SAP. Automates test\u00e9s : M221 Schneider Electric codes fonctions 3,16 et 23, serveur modbus int\u00e9gr\u00e9 M340 Schneider Electric code fonctions 3 et 16, serveur modbus int\u00e9gr\u00e9 Unilogic Unitronics codes fonctions 3,16 et 23, configuration du serveur Modbus requise : L'exemple ci-dessous utilise EcoStruxure Basic Expert de SchneiderElectric qui permet la programmation et la simulation des automates de la famille M221.","title":"Pr\u00e9ambule"},{"location":"fr/plc/#exemple-ascenseur","text":"(fichiers 15-demo_ascenseur_M221.xrs et 15-demo_ascenseur_M221.smbp)","title":"Exemple ascenseur"},{"location":"fr/plc/#preparation-cote-wrsimulateur","text":"La commande de l'ascenseur n\u00e9cessite 8 entr\u00e9es et 4 sorties TOR. On peut utiliser un M221 type TM221CE16R qui dispose de 9 entr\u00e9es TOR et de 7 sorties \u00e0 relais. Adressage des entr\u00e9es TOR : %I0.0, %I0.1, %I0.2, %I0.3, %I0.4, %I0.5, %I0.6, %I0.7, %I0.8 Adressage des sorties : %Q0.0, %Q0.1, %Q0.2, %Q0.3, %Q0.4, %Q0.5, %Q0.6 L'exemple \u00e9tudi\u00e9 implante 8 objets d'entr\u00e9e et 4 objets de sortie en les identifiant avec les adresses API standards. Affectation des entr\u00e9es adresse mn\u00e9monique commentaire %I0.0 E3 appel \u00e9tage 3 %I0.1 E2 appel \u00e9tage 2 %I0.2 E1 appel \u00e9tage 1 %I0.3 P1 cabine \u00e0 l\u00e9tage 1 %I0.4 P2 cabine \u00e0 l\u00e9tage 2 %I0.5 P3 cabine \u00e0 l\u00e9tage 3 %I0.6 PF porte cabine ferm\u00e9e %I0.7 PO porte cabine ouverte Affectation des sorties adresse mn\u00e9monique commentaire %Q0.0 OUVRIR Ouvrir porte %Q0.1 FERMER Fermer porte %Q0.2 DESCENDRE Descendre cage %Q0.3 MONTER Monter cage","title":"Pr\u00e9paration c\u00f4t\u00e9 WRsimulateur :"},{"location":"fr/plc/#preparation-cote-ecostruxure-machine-expert-basic","text":"Le programme complet 15-demo_ascenseur_M221.smbp est disponible dans le dossier : Mise en correspondance des tableaux d'entr\u00e9es/sorties avec la table d'\u00e9change ajust\u00e9e sur l'adresse de d\u00e9part %MW400 voir le mappage modbus : adresse mappage MODBUS mn\u00e9monique commentaire %I0.0 %MW500 :X0 E3 appel \u00e9tage 3 %I0.1 %MW500 :X1 E2 appel \u00e9tage 2 %I0.2 %MW500 :X2 E1 appel \u00e9tage 1 %I0.3 %MW500 :X3 P1 cabine \u00e0 l\u00e9tage 1 %I0.4 %MW500 :X4 P2 cabine \u00e0 l\u00e9tage 2 %I0.5 %MW500 :X5 P3 cabine \u00e0 l\u00e9tage 3 %I0.6 %MW500 :X6 PF porte cabine ferm\u00e9e %I0.7 %MW500 :X7 PO porte cabine ouverte adresse mappage MODBUS mn\u00e9monique commentaire %Q0.0 %MW400 :X0 OUVRIR Ouvrir porte %Q0.1 %MW400 :X1 FERMER Fermer porte %Q0.2 %MW400 :X2 DESCENDRE Descendre cage %Q0.3 %MW401 :X3 MONTER Monter cage Dans l'onglet Programmation ->Outils -> Liste de symboles , on trouve l'assignation des entr\u00e9es/sorties qui correspond aux tableaux pr\u00e9c\u00e9dents: Programme API : D\u00e9marrer le contr\u00f4leur AVANT de lancer le simulateur en activant les boutons Lancer le simulateur et D\u00e9marrer le contr\u00f4leur dans l'onglet Mise en service d'EcoStruxure:","title":"Pr\u00e9paration c\u00f4t\u00e9 EcoStruxure Machine Expert--Basic"},{"location":"fr/plc/#construction-dun-objet-api","text":"Un automate est construit avec les objets \u00e9l\u00e9mentaires : input# pour les entr\u00e9es TOR, output# pour les sorties TOR, analog_input# pour les entr\u00e9es analogiques, analog_output# pour les sorties analogiques, plc_supply# pour l'alimentation de l'API Toutes les E/S ont pour parent l'objet plc_supply afin d'asservir l'alimentation de ces E/S \u00e0 l'alimentation de l'automate. Le serveur MODBUS est implicitement attach\u00e9 \u00e0 l'automate en place dans le sch\u00e9ma. On ne peut placer qu'un seul automate dans le sch\u00e9ma. Des exemples d'automates sont disponibles dans le dossier blocs_simulables \u00e0 partir de la commande 'Ouvrir un bloc' de WinRelais. Toutes ces empreintes d'automate sont ajustables et modifiables selon les besoins.","title":"Construction d'un objet API"},{"location":"fr/plc/#entreessorties-logiques","text":"input, output biblioth\u00e8que _api %Ir.v ou %Qr.v r = [0,5] v = [0,31] parent = nom de l'objet plc_supply#","title":"Entr\u00e9es/Sorties logiques"},{"location":"fr/plc/#entrees-analogiques","text":"analog_input biblioth\u00e8que _api %IWr.v r = [0,5] v = [0,3] parent = nom de l'objet plc_supply# input_type = U ou I input_range = (min,max) V [-10,10] V ou (min,max) mA [0, 20] mA input_scale = min,max [-32768, 32767]","title":"Entr\u00e9es analogiques"},{"location":"fr/plc/#sorties-analogiques","text":"analog_output biblioth\u00e8que _api %QW0.0 r = [0,5] v = [0,3] parent = nom de l'objet plc_supply# output_type = U ou I output_range = (min,max) V [-10,10] V ou (min,max) mA [0, 20] mA output_scale = min,max [-32768, 32767]","title":"Sorties analogiques"},{"location":"fr/simulator/","text":"Simulateur Int\u00e9gration dans WinRelais Le simulateur est actif par d\u00e9faut. L'activation param\u00e8tre WinRelais avec les r\u00e9glages suivants ( Outils/Options ) : La touche clavier k permet d'afficher/cacher les textures appliqu\u00e9es aux objets simulables : Le lancement du simulateur est r\u00e9alis\u00e9 en cliquant sur l'ic\u00f4ne : un clic droit sur un objet simulable permet : d'\u00e9diter ses propri\u00e9t\u00e9s, d'effectuer une rotation au degr\u00e9 pr\u00e8s des objets synoptiques et v\u00e9rins. Restrictions Mod\u00e8le num\u00e9rique Les charges m\u00e9caniques appliqu\u00e9es aux actionneurs (v\u00e9rins, moteurs) sont fixes. Elles correspondent au point de fonctionnement nominal des actionneurs. Les transitoires des courants et des tensions ne sont pas simul\u00e9es. La fr\u00e9quence maximale d'acquisition des appareils de mesure est limit\u00e9e \u00e0 50Hz (1 mesure toutes les 20 ms). Les mesures sont donn\u00e9es en valeur efficace ou moyenne uniquement. Edition des sch\u00e9mas Il n'existe pas pour l'instant de 'moulinette' pour convertir des sch\u00e9mas ant\u00e9rieurs en sch\u00e9mas simulables. L'\u00e9paisseur des traits pour les conducteurs est fixe. Seule la police de caract\u00e8res 'Arial' est support\u00e9e. L'alignement de texte support\u00e9 est 'gauche' uniquement. Les caract\u00e8res gras et italiques sont transform\u00e9s en caract\u00e8res normaux. Les cadres et les cartouches de folio ne sont pas dessin\u00e9s dans le simulateur. Une seule taille de symbole est utilisable : la taille 'normale'. Edition des symboles dans WinSymbole Certaines fonctionnalit\u00e9s graphiques propos\u00e9es par WinSymbole ne sont pas prises en compte par le simulateur : Pas de courbe de B\u00e9zier, ni de texte, cercle non rempli uniquement, Epaisseur des contours fixe Pas de graphique SVG Pas d'image d'arri\u00e8re plan Pas de mini-dessin. Anomalie d'\u00e9dition d'un symbole Il peut arriver qu'un d\u00e9calage de la texture et de la forme de collision survienne suite \u00e0 la rotation d'un symbole dans WinRelais. Il est alors n\u00e9cessaire de recentrer l'origine du symbole dans WinSymbole. (Voir page 17 sur la question du barycentre) Il est pr\u00e9f\u00e9rable de mener la rotation plut\u00f4t dans WinSymbole, d'ajuster avec soin le barycentre puis de sauver le symbole pour r\u00e9utilisation. Blocs de configuration g\u00e9n\u00e9raux Ce bloc ajuste certains d\u00e9tails d'affichage du folio courant, il est essentiellement utilis\u00e9 \u00e0 des fins de mise au point : collisions = (False/True) : visualise les formes de collision des objets physiques, sensors_collisions = (False/True) : visualise les formes de collision des d\u00e9tecteurs et des fins de course, wrs_equips = (False/True) : visualise les num\u00e9ros des \u00e9quipotentiels d\u00e9finis par le simulateur, wr_equips = (False/True) : visualise les num\u00e9ros des \u00e9quipotentiels d\u00e9finis dans WinRelais, terminals_nums = (False/True) : visualise les num\u00e9ros de bornes des appareils. Les blocs World_Settings d\u00e9finissent le comportement du moteur physique 2D. Il est possible d'ajuster le moteur en : vue de dessus (Top view) : la gravit\u00e9 n'est pas prise en compte, vue de c\u00f4t\u00e9 (Side view) : la gravit\u00e9 est prise en compte. On ne peut placer qu'un seul bloc World_Settings par folio. Il est possible d'avoir des vues diff\u00e9rentes d'un folio \u00e0 l'autre, par exemple : un folio avec un espace physique d\u00e9crit en vue de dessus, le folio suivant avec un espace physique en vue de c\u00f4t\u00e9. Le coefficient de ' damping ', compris entre 0 et 1, simule la friction de l'air qui s'exerce sur un mobile.","title":"Simulateur"},{"location":"fr/simulator/#simulateur","text":"","title":"Simulateur"},{"location":"fr/simulator/#integration-dans-winrelais","text":"Le simulateur est actif par d\u00e9faut. L'activation param\u00e8tre WinRelais avec les r\u00e9glages suivants ( Outils/Options ) : La touche clavier k permet d'afficher/cacher les textures appliqu\u00e9es aux objets simulables : Le lancement du simulateur est r\u00e9alis\u00e9 en cliquant sur l'ic\u00f4ne : un clic droit sur un objet simulable permet : d'\u00e9diter ses propri\u00e9t\u00e9s, d'effectuer une rotation au degr\u00e9 pr\u00e8s des objets synoptiques et v\u00e9rins.","title":"Int\u00e9gration dans WinRelais"},{"location":"fr/simulator/#modele-numerique","text":"Les charges m\u00e9caniques appliqu\u00e9es aux actionneurs (v\u00e9rins, moteurs) sont fixes. Elles correspondent au point de fonctionnement nominal des actionneurs. Les transitoires des courants et des tensions ne sont pas simul\u00e9es. La fr\u00e9quence maximale d'acquisition des appareils de mesure est limit\u00e9e \u00e0 50Hz (1 mesure toutes les 20 ms). Les mesures sont donn\u00e9es en valeur efficace ou moyenne uniquement.","title":"Mod\u00e8le num\u00e9rique"},{"location":"fr/simulator/#edition-des-schemas","text":"Il n'existe pas pour l'instant de 'moulinette' pour convertir des sch\u00e9mas ant\u00e9rieurs en sch\u00e9mas simulables. L'\u00e9paisseur des traits pour les conducteurs est fixe. Seule la police de caract\u00e8res 'Arial' est support\u00e9e. L'alignement de texte support\u00e9 est 'gauche' uniquement. Les caract\u00e8res gras et italiques sont transform\u00e9s en caract\u00e8res normaux. Les cadres et les cartouches de folio ne sont pas dessin\u00e9s dans le simulateur. Une seule taille de symbole est utilisable : la taille 'normale'.","title":"Edition des sch\u00e9mas"},{"location":"fr/simulator/#edition-des-symboles-dans-winsymbole","text":"Certaines fonctionnalit\u00e9s graphiques propos\u00e9es par WinSymbole ne sont pas prises en compte par le simulateur : Pas de courbe de B\u00e9zier, ni de texte, cercle non rempli uniquement, Epaisseur des contours fixe Pas de graphique SVG Pas d'image d'arri\u00e8re plan Pas de mini-dessin.","title":"Edition des symboles dans WinSymbole"},{"location":"fr/simulator/#anomalie-dedition-dun-symbole","text":"Il peut arriver qu'un d\u00e9calage de la texture et de la forme de collision survienne suite \u00e0 la rotation d'un symbole dans WinRelais. Il est alors n\u00e9cessaire de recentrer l'origine du symbole dans WinSymbole. (Voir page 17 sur la question du barycentre) Il est pr\u00e9f\u00e9rable de mener la rotation plut\u00f4t dans WinSymbole, d'ajuster avec soin le barycentre puis de sauver le symbole pour r\u00e9utilisation.","title":"Anomalie d'\u00e9dition d'un symbole"},{"location":"fr/simulator/#blocs-de-configuration-generaux","text":"Ce bloc ajuste certains d\u00e9tails d'affichage du folio courant, il est essentiellement utilis\u00e9 \u00e0 des fins de mise au point : collisions = (False/True) : visualise les formes de collision des objets physiques, sensors_collisions = (False/True) : visualise les formes de collision des d\u00e9tecteurs et des fins de course, wrs_equips = (False/True) : visualise les num\u00e9ros des \u00e9quipotentiels d\u00e9finis par le simulateur, wr_equips = (False/True) : visualise les num\u00e9ros des \u00e9quipotentiels d\u00e9finis dans WinRelais, terminals_nums = (False/True) : visualise les num\u00e9ros de bornes des appareils. Les blocs World_Settings d\u00e9finissent le comportement du moteur physique 2D. Il est possible d'ajuster le moteur en : vue de dessus (Top view) : la gravit\u00e9 n'est pas prise en compte, vue de c\u00f4t\u00e9 (Side view) : la gravit\u00e9 est prise en compte. On ne peut placer qu'un seul bloc World_Settings par folio. Il est possible d'avoir des vues diff\u00e9rentes d'un folio \u00e0 l'autre, par exemple : un folio avec un espace physique d\u00e9crit en vue de dessus, le folio suivant avec un espace physique en vue de c\u00f4t\u00e9. Le coefficient de ' damping ', compris entre 0 et 1, simule la friction de l'air qui s'exerce sur un mobile.","title":"Blocs de configuration g\u00e9n\u00e9raux"},{"location":"fr/speed_controller/","text":"Variateur de vitesse Pr\u00e9ambule WRsimulateur permet d'ins\u00e9rer des variateurs de vitesse dans les folios. La biblioth\u00e8que comprend actuellement des objets variateurs monophas\u00e9s et triphas\u00e9s type ATV31 de SchneiderElectric. L'exemple 18-demo_variateurATV31 illustre une mise en \u0153uvre d'un variateur ATV31 pour contr\u00f4ler la vitesse de d\u00e9placement dune table mobile. le variateur est attach\u00e9 \u00e0 une une zone texte \u00e9dit\u00e9e dans WinRelais qui pr\u00e9cise son param\u00e9trage, Il faut que la premi\u00e8re ligne de la zone de texte commence avec la commande : parent = nom du variateur, cette zone texte peut-\u00eatre plac\u00e9e librement dans le sch\u00e9ma, si la zone texte n'existe pas, le variateur est param\u00e9tr\u00e9 en param\u00e9trage par d\u00e9faut. Param\u00e8tres ATV31 ATV31_programming_manual_FR_1624588_04.pdf Param\u00e8tre par d\u00e9faut Description In = 10 Calibre du variateur bFr = 50 Fr\u00e9quence standard moteur [50,60] ItH = 10.0 Protection thermique du moteur [0.2 \u00e0 1.5 In] CLI = 15.0 Limitation de courant [0.25 \u00e0 1.5 In] ACC = 3.0 Temps de la rampe de d'acc\u00e9l\u00e9ration [0.1 \u00e0 3276 s] dEC = 3.0 Temps de la rampe de d\u00e9c\u00e9l\u00e9ration [0.1 \u00e0 3276 s] LSP = 0 Petite vitesse [0 Hz \u00e0 HSP] HSP = 50 Grande vitesse [LSP \u00e0 bFR] PS2 = n0 2 vitesses pr\u00e9s\u00e9lectionn\u00e9es [n0,LI3,LI4,LI5,LI6] PS4 = n0 4 vitesses pr\u00e9s\u00e9lectionn\u00e9es [n0,LI3,LI4,LI5,LI6] PS8 = n0 8 vitesses pr\u00e9s\u00e9lectionn\u00e9es [n0,LI3,LI4,LI5,LI6] SP2 = 10 Vitesse pr\u00e9s\u00e9lectionn\u00e9e 2 [0 Hz \u00e0 HSP] SP3 = 15 Vitesse pr\u00e9s\u00e9lectionn\u00e9e 3 [0 Hz \u00e0 HSP] SP4 = 20 Vitesse pr\u00e9s\u00e9lectionn\u00e9e 4 [0 Hz \u00e0 HSP] SP5 = 25 Vitesse pr\u00e9s\u00e9lectionn\u00e9e 5 [0 Hz \u00e0 HSP] SP6 = 30 Vitesse pr\u00e9s\u00e9lectionn\u00e9e 6 [0 Hz \u00e0 HSP] SP7 = 35 Vitesse pr\u00e9s\u00e9lectionn\u00e9e 7 [0 Hz \u00e0 HSP] SP8 = 40 Vitesse pr\u00e9s\u00e9lectionn\u00e9e 8 [0 Hz \u00e0 HSP] tCC = 2C Commande 2fils / 3fils [2C, 3C] tCt = trn Type de commande 2fils [LEL, trn, PFO] r1 = FLt Relais r1 [n0,FLt,rUn,FtA,FLA,CtA,SrA,tSA,APL,LI1,LI2,LI3,LI4,LI5,LI6] r2 = n0 Relais r2 [n0,FLt,rUn,FtA,FLA,CtA,SrA,tSA,bLC,APL,LI1,LI2,LI3,LI4,LI5,LI6] FSt = n0 Arr\u00eat rapide sur \u00e9tat logique 0 [n0, LI1, LI2, LI3, LI4, LI5, LI6] LAF = n0 Fin de course sens avant [n0, LI1, LI2, LI3, LI4, LI5,LI6] LAr = n0 Fin de course sens avant [n0, LI1, LI2, LI3, LI4, LI5,LI6] LAS = nSt Type d'arr\u00eat en fin de course [rMP, FSt, nSt] FR1 = AII Configuration consigne 1 [AII, AI2, AI3] Param\u00e8tres ATV11 ATV11_UserManual.pdf Param\u00e8tre par d\u00e9faut Description In = 10 Calibre du variateur bFr = 50 Fr\u00e9quence standard moteur [50,60] ItH = 10.0 Protection thermique du moteur [0.2 \u00e0 1.5 In] CLI = 15.0 Limitation de courant [0.25 \u00e0 1.5 In] ACC = 3.0 Temps de la rampe de d'acc\u00e9l\u00e9ration [0.1 \u00e0 3276 s] dEC = 3.0 Temps de la rampe de d\u00e9c\u00e9l\u00e9ration [0.1 \u00e0 3276 s] LSP = 0 Petite vitesse [0 Hz \u00e0 HSP] HSP = 50 Grande vitesse [LSP \u00e0 bFR] SP2 = 10 Vitesse pr\u00e9s\u00e9lectionn\u00e9e 2 [0 Hz \u00e0 HSP] SP3 = 25 Vitesse pr\u00e9s\u00e9lectionn\u00e9e 3 [0 Hz \u00e0 HSP] SP4 = 50 Vitesse pr\u00e9s\u00e9lectionn\u00e9e 4 [0 Hz \u00e0 HSP] Alt = 5U Configuration entr\u00e9e analogique [5U, 10U, 0A, 4A] ACt = 2C Commande 2fils / 3fils [2C, 3C] tCt = trn Type de commande 2fils [LEL, trn, PFO] rrS = n0 Sens arri\u00e8re [n0,LII,LI2,LI3,LI4] LIA = n0 Affectation de l'entr\u00e9e LIA [n0,LII,LI2,LI3,LI4] LIb = n0 Affectation de l'entr\u00e9e LIb [n0,LII,LI2,LI3,LI4] dO = n0 [n0, 0Cr, rFr, FtA, SrA CtA] Ftd = 50 Seuil de fr\u00e9quence (0 \u00e0 200 Hz) Ctd = 10 Seuil de courant [0 \u00e0 1.5 In]","title":"Variateur de vitesse"},{"location":"fr/speed_controller/#variateur-de-vitesse","text":"","title":"Variateur de vitesse"},{"location":"fr/speed_controller/#preambule","text":"WRsimulateur permet d'ins\u00e9rer des variateurs de vitesse dans les folios. La biblioth\u00e8que comprend actuellement des objets variateurs monophas\u00e9s et triphas\u00e9s type ATV31 de SchneiderElectric. L'exemple 18-demo_variateurATV31 illustre une mise en \u0153uvre d'un variateur ATV31 pour contr\u00f4ler la vitesse de d\u00e9placement dune table mobile. le variateur est attach\u00e9 \u00e0 une une zone texte \u00e9dit\u00e9e dans WinRelais qui pr\u00e9cise son param\u00e9trage, Il faut que la premi\u00e8re ligne de la zone de texte commence avec la commande : parent = nom du variateur, cette zone texte peut-\u00eatre plac\u00e9e librement dans le sch\u00e9ma, si la zone texte n'existe pas, le variateur est param\u00e9tr\u00e9 en param\u00e9trage par d\u00e9faut.","title":"Pr\u00e9ambule"},{"location":"fr/speed_controller/#parametres-atv31","text":"ATV31_programming_manual_FR_1624588_04.pdf Param\u00e8tre par d\u00e9faut Description In = 10 Calibre du variateur bFr = 50 Fr\u00e9quence standard moteur [50,60] ItH = 10.0 Protection thermique du moteur [0.2 \u00e0 1.5 In] CLI = 15.0 Limitation de courant [0.25 \u00e0 1.5 In] ACC = 3.0 Temps de la rampe de d'acc\u00e9l\u00e9ration [0.1 \u00e0 3276 s] dEC = 3.0 Temps de la rampe de d\u00e9c\u00e9l\u00e9ration [0.1 \u00e0 3276 s] LSP = 0 Petite vitesse [0 Hz \u00e0 HSP] HSP = 50 Grande vitesse [LSP \u00e0 bFR] PS2 = n0 2 vitesses pr\u00e9s\u00e9lectionn\u00e9es [n0,LI3,LI4,LI5,LI6] PS4 = n0 4 vitesses pr\u00e9s\u00e9lectionn\u00e9es [n0,LI3,LI4,LI5,LI6] PS8 = n0 8 vitesses pr\u00e9s\u00e9lectionn\u00e9es [n0,LI3,LI4,LI5,LI6] SP2 = 10 Vitesse pr\u00e9s\u00e9lectionn\u00e9e 2 [0 Hz \u00e0 HSP] SP3 = 15 Vitesse pr\u00e9s\u00e9lectionn\u00e9e 3 [0 Hz \u00e0 HSP] SP4 = 20 Vitesse pr\u00e9s\u00e9lectionn\u00e9e 4 [0 Hz \u00e0 HSP] SP5 = 25 Vitesse pr\u00e9s\u00e9lectionn\u00e9e 5 [0 Hz \u00e0 HSP] SP6 = 30 Vitesse pr\u00e9s\u00e9lectionn\u00e9e 6 [0 Hz \u00e0 HSP] SP7 = 35 Vitesse pr\u00e9s\u00e9lectionn\u00e9e 7 [0 Hz \u00e0 HSP] SP8 = 40 Vitesse pr\u00e9s\u00e9lectionn\u00e9e 8 [0 Hz \u00e0 HSP] tCC = 2C Commande 2fils / 3fils [2C, 3C] tCt = trn Type de commande 2fils [LEL, trn, PFO] r1 = FLt Relais r1 [n0,FLt,rUn,FtA,FLA,CtA,SrA,tSA,APL,LI1,LI2,LI3,LI4,LI5,LI6] r2 = n0 Relais r2 [n0,FLt,rUn,FtA,FLA,CtA,SrA,tSA,bLC,APL,LI1,LI2,LI3,LI4,LI5,LI6] FSt = n0 Arr\u00eat rapide sur \u00e9tat logique 0 [n0, LI1, LI2, LI3, LI4, LI5, LI6] LAF = n0 Fin de course sens avant [n0, LI1, LI2, LI3, LI4, LI5,LI6] LAr = n0 Fin de course sens avant [n0, LI1, LI2, LI3, LI4, LI5,LI6] LAS = nSt Type d'arr\u00eat en fin de course [rMP, FSt, nSt] FR1 = AII Configuration consigne 1 [AII, AI2, AI3]","title":"Param\u00e8tres ATV31"},{"location":"fr/speed_controller/#parametres-atv11","text":"ATV11_UserManual.pdf Param\u00e8tre par d\u00e9faut Description In = 10 Calibre du variateur bFr = 50 Fr\u00e9quence standard moteur [50,60] ItH = 10.0 Protection thermique du moteur [0.2 \u00e0 1.5 In] CLI = 15.0 Limitation de courant [0.25 \u00e0 1.5 In] ACC = 3.0 Temps de la rampe de d'acc\u00e9l\u00e9ration [0.1 \u00e0 3276 s] dEC = 3.0 Temps de la rampe de d\u00e9c\u00e9l\u00e9ration [0.1 \u00e0 3276 s] LSP = 0 Petite vitesse [0 Hz \u00e0 HSP] HSP = 50 Grande vitesse [LSP \u00e0 bFR] SP2 = 10 Vitesse pr\u00e9s\u00e9lectionn\u00e9e 2 [0 Hz \u00e0 HSP] SP3 = 25 Vitesse pr\u00e9s\u00e9lectionn\u00e9e 3 [0 Hz \u00e0 HSP] SP4 = 50 Vitesse pr\u00e9s\u00e9lectionn\u00e9e 4 [0 Hz \u00e0 HSP] Alt = 5U Configuration entr\u00e9e analogique [5U, 10U, 0A, 4A] ACt = 2C Commande 2fils / 3fils [2C, 3C] tCt = trn Type de commande 2fils [LEL, trn, PFO] rrS = n0 Sens arri\u00e8re [n0,LII,LI2,LI3,LI4] LIA = n0 Affectation de l'entr\u00e9e LIA [n0,LII,LI2,LI3,LI4] LIb = n0 Affectation de l'entr\u00e9e LIb [n0,LII,LI2,LI3,LI4] dO = n0 [n0, 0Cr, rFr, FtA, SrA CtA] Ftd = 50 Seuil de fr\u00e9quence (0 \u00e0 200 Hz) Ctd = 10 Seuil de courant [0 \u00e0 1.5 In]","title":"Param\u00e8tres ATV11"},{"location":"fr/synoptic/","text":"Synoptique Pr\u00e9ambule Le simulateur permet de cr\u00e9er des petites parties op\u00e9ratives contr\u00f4lables avec les actionneurs du sch\u00e9ma. Il int\u00e8gre un moteur physique 2D pour apporter un certain r\u00e9alisme \u00e0 la simulation. Exemple : Cet exemple montre deux bidons cylindriques vus de c\u00f4t\u00e9 pos\u00e9s sur une rampe inclin\u00e9e. Lorsque la tige du v\u00e9rin sort, les deux bidons sont remont\u00e9s vers le haut de la rampe. Lorsque la tige du v\u00e9rin rentre, les deux bidons roulent (ou glissent selon le coefficient de frottement appliqu\u00e9) vers le bas de la rampe en restant finalement bloqu\u00e9s en position par le nez du v\u00e9rin. Deux types d'objets sont utilis\u00e9s par le moteur physique : les objets physiques qui sont soumis aux forces ext\u00e9rieures et \u00e0 la gravit\u00e9. Ils ont notamment une masse en kilogrammes les objets kin\u00e9matiques ont leurs positions dans la sc\u00e8ne contr\u00f4l\u00e9s directement par le programme. Ils sont insensibles aux forces ext\u00e9rieures et donc non soumis aux lois de la physique. Les objets physiques peuvent entrer en collision avec les objets kin\u00e9matiques. Param\u00e9trage objet physique shape biblioth\u00e8que \\_Physique dynamique = True -> l'objet est de type 'physique', False -> l'objet est de type 'kin\u00e9matique' masse = masse en kg de l'objet physique [1 \u00e0 100 kg] friction = coefficient de friction [0 \u00e0 100] appliqu\u00e9 \u00e0 l'objet physique pas_de_rotation = applique une masse et une valeur d'inertie consid\u00e9rable \u00e0 l'objet physique id_collision = * (valeur par d\u00e9faut) nom_texture = nom de l'image (format png uniquement) si dynamique = False, les param\u00e8tres masse et friction sont ignor\u00e9s. Param\u00e9trage objet kin\u00e9matique kinematic biblioth\u00e8que \\_Synoptique parent = d\u00e9signe un parent qui ne peut-\u00eatre qu'une liaison glissi\u00e8re id_collision = * (valeur par d\u00e9faut) nom_texture = nom de l'image qui peut \u00eatre appliqu\u00e9 \u00e0 l'objet (format png uniquement) show = True (False ou True) montrer/cacher l'objet Un objet kin\u00e9matique peut-\u00eatre attach\u00e9 \u00e0 une liaison glissi\u00e8re. Le param\u00e8tre show permet l'utilisation de 'murs' invisibles. D\u00e9tecteur et Fin de course D\u00e9tecte des objets physiques et kin\u00e9matiques qui entrent dans la zone de d\u00e9tection du d\u00e9tecteur/Fin de course Un d\u00e9tecteur (sensor) est un objet kin\u00e9matique sp\u00e9cialis\u00e9 disponible dans la biblioth\u00e8que _Synoptique sensor biblioth\u00e8que \\_Synoptique parent = d\u00e9signe un parent qui ne peut-\u00eatre qu'une liaison glissi\u00e8re id_collision = * (valeur par d\u00e9faut, d\u00e9tecte tous les objets pr\u00e9sents dans la zone de d\u00e9tection) nom_texture = nom de l'image qui peut \u00eatre appliqu\u00e9e \u00e0 l'objet (format png uniquement) * = fixe la position du voyant indicateur (carr\u00e9 vert) Un d\u00e9tecteur avec id_collision = * d\u00e9tecte tous les objets qui entrent dans sa zone de d\u00e9tection. id_collision permet de filtrer les objets d\u00e9tect\u00e9s par un composant d\u00e9tecteur ou fin de course. Par exemple : Filtrage des objets en collision le sensor A d\u00e9tecte uniquement l'objet P2 le sensor * d\u00e9tecte les objets P1, P2 et P3 sensor B d\u00e9tecte uniquement l'objet P3 La zone de d\u00e9tection d'un d\u00e9tecteur est d\u00e9finie par un contour de couleur magenta (255,0,255) (255,0,255) . Par exemple : Si un nom de texture est d\u00e9fini, l'application recherche la texture (au format png seulement) dans le dossier C:\\Users\\Public\\Documents\\Elec-CAO\\wrs-data\\textures Si le nom de la texture n'est pas d\u00e9fini ou si le fichier texture n'est pas trouv\u00e9, une texture calcul\u00e9e par le programme sera plaqu\u00e9e sur l'objet en utilisant le bord ext\u00e9rieur color\u00e9 en rouge . Par exemple : La silhouette de la texture permet de d\u00e9finir automatiquement la forme de collision de l'objet. - Le moteur physique utilise la partie transparente de la texture pour d\u00e9limiter la forme de collision sous la forme d'un polygone convexe comme montr\u00e9 ci-dessous : Contrainte de dessin dans WinSymbole Liaison glissi\u00e8re (slider) Les liaisons glissi\u00e8res sont disponibles dans la biblioth\u00e8que _Synoptique et sont pr\u00e9fix\u00e9es avec le mot clef slider : Description des param\u00e8tres d'un slider : slider biblioth\u00e8que \\_Synoptique controle_direction = d\u00e9signe l'objet moteur utilis\u00e9 pour contr\u00f4ler le mobile en direction controle_vitesse = d\u00e9signe l'objet moteur utilis\u00e9 pour contr\u00f4ler le mobile en vitesse vitesse = vitesse en % de la vitesse du moteur (transcrite en vitesse lin\u00e9aire). [0 \u00e0100%] friction = fixe la friction de la surface du mobile [0 \u00e0 100] id_collision = * (valeur par d\u00e9faut, d\u00e9tecte tout objet entrant en collision) parent = d\u00e9signe un parent qui ne peut-\u00eatre qu'une autre liaison glissi\u00e8re nom_texture = nom de la texture qui peut-\u00eatre appliqu\u00e9e au mobile. El\u00e9ments constitutifs d'une liaison glissi\u00e8re \u00e9ditables dans WinSymbole : Ces \u00e9l\u00e9ments sont diff\u00e9renti\u00e9s dans WinSymbole gr\u00e2ce \u00e0 des couleurs pr\u00e9cises : (255,128,255) identifie la ligne directrice et les limites de d\u00e9placement (symboles carr\u00e9 et cercle), (255,0,0) identifie le contour ext\u00e9rieur du mobile. Ce contour doit \u00eatre un polygone convexe unique, (255,0,255) identifie la forme de collision optionnelle qui doit \u00eatre un polygone convexe unique. Si ce polygone n'est pas d\u00e9fini, le moteur physique calcule la forme de collision \u00e0 partir du contour ext\u00e9rieur rouge. Exemples Actionneur v\u00e9rin Un v\u00e9rin est une liaison glissi\u00e8re sp\u00e9cialis\u00e9e. VerinSE, VerinDE biblioth\u00e8que \\_Verins pression = pression nominale [0 \u00e0 10 bar] vitesse = coefficient de vitesse de d\u00e9placement de la tige [0 \u00e0 100%] id_collision = * (valeur par d\u00e9faut, d\u00e9tecte tout objet entrant en collision) nom_texture = nom de la texture qui peut-\u00eatre appliqu\u00e9e \u00e0 la tige Actionneur v\u00e9rin flottant Il est identique au composant v\u00e9rin, \u00e0 ceci pr\u00e9s qu'il peut-\u00eatre attach\u00e9 \u00e0 une liaison glissi\u00e9re. Il est syst\u00e9matiquement associ\u00e9 : \u00e0 un objet Label_Pression pour le v\u00e9rin simple effet, \u00e0 deux objets Label_Pression pour le v\u00e9rin double effet Les noms des objets Label_Pression sont utilis\u00e9s dans le param\u00e8tre float_inputs (ou float_input ) pour connecter les orifices des v\u00e9rins. VerinDE_flottant biblioth\u00e8que \\_Verins float_inputs = (Label_Pression orifice 1, Label_Pression orifice 2) parent = d\u00e9signe un parent qui ne peut-\u00eatre qu'une autre liaison glissi\u00e8re pression = pression nominale [0 \u00e0 10 bar] vitesse = coefficient de vitesse de d\u00e9placement de la tige [0 \u00e0 100%] id_collision = * (valeur par d\u00e9faut, d\u00e9tecte tout objet entrant en collision) nom_texture = nom de la texture qui peut-\u00eatre appliqu\u00e9e \u00e0 la tige VerinSE_flottant biblioth\u00e8que \\_Verins float_input = Label_Pression orifice 1 parent = d\u00e9signe un parent qui ne peut-\u00eatre qu'une autre liaison glissi\u00e8re. pression = pression nominale [0 \u00e0 10 bar] vitesse = coefficient de vitesse de d\u00e9placement de la tige [0 \u00e0 100%] id_collision = * (valeur par d\u00e9faut, d\u00e9tecte tout objet entrant en collision) nom_texture = nom de la texture qui peut-\u00eatre appliqu\u00e9e \u00e0 la tige Liaison glissi\u00e8re et parent\u00e9 Tous les objets kin\u00e9matiques peuvent \u00eatre attach\u00e9s \u00e0 une liaison glissi\u00e8re. Ceci est extr\u00eamement pratique pour cr\u00e9er des formes de collision non convexes, par exemple : Le nez de la tige est un objet kin\u00e9matique attach\u00e9 \u00e0 la tige du v\u00e9rin gr\u00e2ce au param\u00e8tre parent : Il est possible d'attacher plusieurs objets kin\u00e9matiques : Convoyeur en vue de dessus Les convoyeurs en vue de dessus sont disponibles dans la biblioth\u00e8que _Synoptique et sont pr\u00e9fix\u00e9s avec le mot clef conveyor : conveyor biblioth\u00e8que \\_Synoptique controle_direction = objet moteur utilis\u00e9 pour contr\u00f4ler la diection du convoyeur controle_vitesse = objet moteur utilis\u00e9 pour contr\u00f4ler la vitesse vitesse = vitesse du convoyeur en % de la vitesse du moteur (transcrite en vitesse lin\u00e9aire). [0 \u00e0 100%] friction = fixe la friction du convoyeur [0 \u00e0 100] id_collision = * (valeur par d\u00e9faut) parent = d\u00e9signe un parent qui ne peut-\u00eatre qu'une liaison glissi\u00e8re nom_texture = nom de la texture qui peut-\u00eatre appliqu\u00e9e au convoyeur Convoyeur en vue de c\u00f4t\u00e9 Les convoyeurs en vue de c\u00f4t\u00e9 sont disponibles dans la biblioth\u00e8que _Synoptique et sont pr\u00e9fix\u00e9s avec le mot clef side_conveyor : side_conveyor biblioth\u00e8que \\_Synoptique controle_direction = objet moteur utilis\u00e9 pour contr\u00f4ler la diection du convoyeur controle_vitesse = objet moteur utilis\u00e9 pour contr\u00f4ler la vitesse vitesse = vitesse du convoyeur en % de la vitesse du moteur (transcrite en vitesse lin\u00e9aire). [0 \u00e0 100%] friction = fixe la friction du convoyeur [0 \u00e0 100] id_collision = * (valeur par d\u00e9faut) parent = d\u00e9signe un parent qui ne peut-\u00eatre qu'une liaison glissi\u00e8re nom_texture = nom de la texture qui peut-\u00eatre appliqu\u00e9e au convoyeur Objet dispenser Voir 38 - demo_Convoyeurs.xrs Objet synoptique sp\u00e9cialis\u00e9 qui permet de distribuer un objet physique dans la sc\u00e8ne \u00e0 intervalle r\u00e9gulier. Il est n\u00e9cessaire de placer au moins un exemplaire de l'objet \u00e0 distribuer dans la sc\u00e8ne. Le nombre d'objets distribu\u00e9 est limit\u00e9 \u00e0 16. dispenser biblioth\u00e8que \\_Synoptique id_collision = * (valeur par d\u00e9faut) parent = d\u00e9signe un parent qui ne peut-\u00eatre qu'une liaison glissi\u00e8re nom_texture = nom de la texture qui peut-\u00eatre appliqu\u00e9e au dispenser dropped_object = nom de l'objet physique distribu\u00e9 * fixe le point de distribbution delay = intervalle de distribution en secondes [0.1 s \u00e0 30 s] show = True (False ou True) montrer/cacher l'objet si dispenser est associ\u00e9 \u00e0 un bouton de potentiom\u00e8tre, l'intervalle de distribution est ajustable ente 0.1 s et delay Sous-ensembles synoptiques On peut sauver et r\u00e9cup\u00e9rer des synoptiques complets gr\u00e2ce aux commandes de blocs de WinRelais. Exemple de synoptique import\u00e9 tri_de_caisses :","title":"Synoptique"},{"location":"fr/synoptic/#synoptique","text":"","title":"Synoptique"},{"location":"fr/synoptic/#preambule","text":"Le simulateur permet de cr\u00e9er des petites parties op\u00e9ratives contr\u00f4lables avec les actionneurs du sch\u00e9ma. Il int\u00e8gre un moteur physique 2D pour apporter un certain r\u00e9alisme \u00e0 la simulation. Exemple : Cet exemple montre deux bidons cylindriques vus de c\u00f4t\u00e9 pos\u00e9s sur une rampe inclin\u00e9e. Lorsque la tige du v\u00e9rin sort, les deux bidons sont remont\u00e9s vers le haut de la rampe. Lorsque la tige du v\u00e9rin rentre, les deux bidons roulent (ou glissent selon le coefficient de frottement appliqu\u00e9) vers le bas de la rampe en restant finalement bloqu\u00e9s en position par le nez du v\u00e9rin. Deux types d'objets sont utilis\u00e9s par le moteur physique : les objets physiques qui sont soumis aux forces ext\u00e9rieures et \u00e0 la gravit\u00e9. Ils ont notamment une masse en kilogrammes les objets kin\u00e9matiques ont leurs positions dans la sc\u00e8ne contr\u00f4l\u00e9s directement par le programme. Ils sont insensibles aux forces ext\u00e9rieures et donc non soumis aux lois de la physique. Les objets physiques peuvent entrer en collision avec les objets kin\u00e9matiques.","title":"Pr\u00e9ambule"},{"location":"fr/synoptic/#parametrage-objet-physique","text":"shape biblioth\u00e8que \\_Physique dynamique = True -> l'objet est de type 'physique', False -> l'objet est de type 'kin\u00e9matique' masse = masse en kg de l'objet physique [1 \u00e0 100 kg] friction = coefficient de friction [0 \u00e0 100] appliqu\u00e9 \u00e0 l'objet physique pas_de_rotation = applique une masse et une valeur d'inertie consid\u00e9rable \u00e0 l'objet physique id_collision = * (valeur par d\u00e9faut) nom_texture = nom de l'image (format png uniquement) si dynamique = False, les param\u00e8tres masse et friction sont ignor\u00e9s.","title":"Param\u00e9trage objet physique"},{"location":"fr/synoptic/#parametrage-objet-kinematique","text":"kinematic biblioth\u00e8que \\_Synoptique parent = d\u00e9signe un parent qui ne peut-\u00eatre qu'une liaison glissi\u00e8re id_collision = * (valeur par d\u00e9faut) nom_texture = nom de l'image qui peut \u00eatre appliqu\u00e9 \u00e0 l'objet (format png uniquement) show = True (False ou True) montrer/cacher l'objet Un objet kin\u00e9matique peut-\u00eatre attach\u00e9 \u00e0 une liaison glissi\u00e8re. Le param\u00e8tre show permet l'utilisation de 'murs' invisibles.","title":"Param\u00e9trage objet kin\u00e9matique"},{"location":"fr/synoptic/#detecteur-et-fin-de-course","text":"D\u00e9tecte des objets physiques et kin\u00e9matiques qui entrent dans la zone de d\u00e9tection du d\u00e9tecteur/Fin de course Un d\u00e9tecteur (sensor) est un objet kin\u00e9matique sp\u00e9cialis\u00e9 disponible dans la biblioth\u00e8que _Synoptique sensor biblioth\u00e8que \\_Synoptique parent = d\u00e9signe un parent qui ne peut-\u00eatre qu'une liaison glissi\u00e8re id_collision = * (valeur par d\u00e9faut, d\u00e9tecte tous les objets pr\u00e9sents dans la zone de d\u00e9tection) nom_texture = nom de l'image qui peut \u00eatre appliqu\u00e9e \u00e0 l'objet (format png uniquement) * = fixe la position du voyant indicateur (carr\u00e9 vert) Un d\u00e9tecteur avec id_collision = * d\u00e9tecte tous les objets qui entrent dans sa zone de d\u00e9tection. id_collision permet de filtrer les objets d\u00e9tect\u00e9s par un composant d\u00e9tecteur ou fin de course. Par exemple : Filtrage des objets en collision le sensor A d\u00e9tecte uniquement l'objet P2 le sensor * d\u00e9tecte les objets P1, P2 et P3 sensor B d\u00e9tecte uniquement l'objet P3 La zone de d\u00e9tection d'un d\u00e9tecteur est d\u00e9finie par un contour de couleur magenta (255,0,255) (255,0,255) . Par exemple : Si un nom de texture est d\u00e9fini, l'application recherche la texture (au format png seulement) dans le dossier C:\\Users\\Public\\Documents\\Elec-CAO\\wrs-data\\textures Si le nom de la texture n'est pas d\u00e9fini ou si le fichier texture n'est pas trouv\u00e9, une texture calcul\u00e9e par le programme sera plaqu\u00e9e sur l'objet en utilisant le bord ext\u00e9rieur color\u00e9 en rouge . Par exemple : La silhouette de la texture permet de d\u00e9finir automatiquement la forme de collision de l'objet. - Le moteur physique utilise la partie transparente de la texture pour d\u00e9limiter la forme de collision sous la forme d'un polygone convexe comme montr\u00e9 ci-dessous : Contrainte de dessin dans WinSymbole","title":"D\u00e9tecteur et Fin de course"},{"location":"fr/synoptic/#liaison-glissiere-slider","text":"Les liaisons glissi\u00e8res sont disponibles dans la biblioth\u00e8que _Synoptique et sont pr\u00e9fix\u00e9es avec le mot clef slider : Description des param\u00e8tres d'un slider : slider biblioth\u00e8que \\_Synoptique controle_direction = d\u00e9signe l'objet moteur utilis\u00e9 pour contr\u00f4ler le mobile en direction controle_vitesse = d\u00e9signe l'objet moteur utilis\u00e9 pour contr\u00f4ler le mobile en vitesse vitesse = vitesse en % de la vitesse du moteur (transcrite en vitesse lin\u00e9aire). [0 \u00e0100%] friction = fixe la friction de la surface du mobile [0 \u00e0 100] id_collision = * (valeur par d\u00e9faut, d\u00e9tecte tout objet entrant en collision) parent = d\u00e9signe un parent qui ne peut-\u00eatre qu'une autre liaison glissi\u00e8re nom_texture = nom de la texture qui peut-\u00eatre appliqu\u00e9e au mobile. El\u00e9ments constitutifs d'une liaison glissi\u00e8re \u00e9ditables dans WinSymbole : Ces \u00e9l\u00e9ments sont diff\u00e9renti\u00e9s dans WinSymbole gr\u00e2ce \u00e0 des couleurs pr\u00e9cises : (255,128,255) identifie la ligne directrice et les limites de d\u00e9placement (symboles carr\u00e9 et cercle), (255,0,0) identifie le contour ext\u00e9rieur du mobile. Ce contour doit \u00eatre un polygone convexe unique, (255,0,255) identifie la forme de collision optionnelle qui doit \u00eatre un polygone convexe unique. Si ce polygone n'est pas d\u00e9fini, le moteur physique calcule la forme de collision \u00e0 partir du contour ext\u00e9rieur rouge. Exemples","title":"Liaison glissi\u00e8re (slider)"},{"location":"fr/synoptic/#actionneur-verin","text":"Un v\u00e9rin est une liaison glissi\u00e8re sp\u00e9cialis\u00e9e. VerinSE, VerinDE biblioth\u00e8que \\_Verins pression = pression nominale [0 \u00e0 10 bar] vitesse = coefficient de vitesse de d\u00e9placement de la tige [0 \u00e0 100%] id_collision = * (valeur par d\u00e9faut, d\u00e9tecte tout objet entrant en collision) nom_texture = nom de la texture qui peut-\u00eatre appliqu\u00e9e \u00e0 la tige","title":"Actionneur v\u00e9rin"},{"location":"fr/synoptic/#actionneur-verin-flottant","text":"Il est identique au composant v\u00e9rin, \u00e0 ceci pr\u00e9s qu'il peut-\u00eatre attach\u00e9 \u00e0 une liaison glissi\u00e9re. Il est syst\u00e9matiquement associ\u00e9 : \u00e0 un objet Label_Pression pour le v\u00e9rin simple effet, \u00e0 deux objets Label_Pression pour le v\u00e9rin double effet Les noms des objets Label_Pression sont utilis\u00e9s dans le param\u00e8tre float_inputs (ou float_input ) pour connecter les orifices des v\u00e9rins. VerinDE_flottant biblioth\u00e8que \\_Verins float_inputs = (Label_Pression orifice 1, Label_Pression orifice 2) parent = d\u00e9signe un parent qui ne peut-\u00eatre qu'une autre liaison glissi\u00e8re pression = pression nominale [0 \u00e0 10 bar] vitesse = coefficient de vitesse de d\u00e9placement de la tige [0 \u00e0 100%] id_collision = * (valeur par d\u00e9faut, d\u00e9tecte tout objet entrant en collision) nom_texture = nom de la texture qui peut-\u00eatre appliqu\u00e9e \u00e0 la tige VerinSE_flottant biblioth\u00e8que \\_Verins float_input = Label_Pression orifice 1 parent = d\u00e9signe un parent qui ne peut-\u00eatre qu'une autre liaison glissi\u00e8re. pression = pression nominale [0 \u00e0 10 bar] vitesse = coefficient de vitesse de d\u00e9placement de la tige [0 \u00e0 100%] id_collision = * (valeur par d\u00e9faut, d\u00e9tecte tout objet entrant en collision) nom_texture = nom de la texture qui peut-\u00eatre appliqu\u00e9e \u00e0 la tige","title":"Actionneur v\u00e9rin flottant"},{"location":"fr/synoptic/#liaison-glissiere-et-parente","text":"Tous les objets kin\u00e9matiques peuvent \u00eatre attach\u00e9s \u00e0 une liaison glissi\u00e8re. Ceci est extr\u00eamement pratique pour cr\u00e9er des formes de collision non convexes, par exemple : Le nez de la tige est un objet kin\u00e9matique attach\u00e9 \u00e0 la tige du v\u00e9rin gr\u00e2ce au param\u00e8tre parent : Il est possible d'attacher plusieurs objets kin\u00e9matiques :","title":"Liaison glissi\u00e8re et parent\u00e9"},{"location":"fr/synoptic/#convoyeur-en-vue-de-dessus","text":"Les convoyeurs en vue de dessus sont disponibles dans la biblioth\u00e8que _Synoptique et sont pr\u00e9fix\u00e9s avec le mot clef conveyor : conveyor biblioth\u00e8que \\_Synoptique controle_direction = objet moteur utilis\u00e9 pour contr\u00f4ler la diection du convoyeur controle_vitesse = objet moteur utilis\u00e9 pour contr\u00f4ler la vitesse vitesse = vitesse du convoyeur en % de la vitesse du moteur (transcrite en vitesse lin\u00e9aire). [0 \u00e0 100%] friction = fixe la friction du convoyeur [0 \u00e0 100] id_collision = * (valeur par d\u00e9faut) parent = d\u00e9signe un parent qui ne peut-\u00eatre qu'une liaison glissi\u00e8re nom_texture = nom de la texture qui peut-\u00eatre appliqu\u00e9e au convoyeur","title":"Convoyeur en vue de dessus"},{"location":"fr/synoptic/#convoyeur-en-vue-de-cote","text":"Les convoyeurs en vue de c\u00f4t\u00e9 sont disponibles dans la biblioth\u00e8que _Synoptique et sont pr\u00e9fix\u00e9s avec le mot clef side_conveyor : side_conveyor biblioth\u00e8que \\_Synoptique controle_direction = objet moteur utilis\u00e9 pour contr\u00f4ler la diection du convoyeur controle_vitesse = objet moteur utilis\u00e9 pour contr\u00f4ler la vitesse vitesse = vitesse du convoyeur en % de la vitesse du moteur (transcrite en vitesse lin\u00e9aire). [0 \u00e0 100%] friction = fixe la friction du convoyeur [0 \u00e0 100] id_collision = * (valeur par d\u00e9faut) parent = d\u00e9signe un parent qui ne peut-\u00eatre qu'une liaison glissi\u00e8re nom_texture = nom de la texture qui peut-\u00eatre appliqu\u00e9e au convoyeur","title":"Convoyeur en vue de c\u00f4t\u00e9"},{"location":"fr/synoptic/#objet-dispenser","text":"Voir 38 - demo_Convoyeurs.xrs Objet synoptique sp\u00e9cialis\u00e9 qui permet de distribuer un objet physique dans la sc\u00e8ne \u00e0 intervalle r\u00e9gulier. Il est n\u00e9cessaire de placer au moins un exemplaire de l'objet \u00e0 distribuer dans la sc\u00e8ne. Le nombre d'objets distribu\u00e9 est limit\u00e9 \u00e0 16. dispenser biblioth\u00e8que \\_Synoptique id_collision = * (valeur par d\u00e9faut) parent = d\u00e9signe un parent qui ne peut-\u00eatre qu'une liaison glissi\u00e8re nom_texture = nom de la texture qui peut-\u00eatre appliqu\u00e9e au dispenser dropped_object = nom de l'objet physique distribu\u00e9 * fixe le point de distribbution delay = intervalle de distribution en secondes [0.1 s \u00e0 30 s] show = True (False ou True) montrer/cacher l'objet si dispenser est associ\u00e9 \u00e0 un bouton de potentiom\u00e8tre, l'intervalle de distribution est ajustable ente 0.1 s et delay","title":"Objet dispenser"},{"location":"fr/synoptic/#sous-ensembles-synoptiques","text":"On peut sauver et r\u00e9cup\u00e9rer des synoptiques complets gr\u00e2ce aux commandes de blocs de WinRelais. Exemple de synoptique import\u00e9 tri_de_caisses :","title":"Sous-ensembles synoptiques"}]}